<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>With An Orchid</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lujianan.com/"/>
  <updated>2021-01-10T13:50:29.194Z</updated>
  <id>http://lujianan.com/</id>
  
  <author>
    <name>Royeo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s 命名空间</title>
    <link href="http://lujianan.com/2021/01/10/kubernetes-namespace/"/>
    <id>http://lujianan.com/2021/01/10/kubernetes-namespace/</id>
    <published>2021-01-10T10:08:30.000Z</published>
    <updated>2021-01-10T13:50:29.194Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="什么是命名空间"><a href="#什么是命名空间" class="headerlink" title="什么是命名空间"></a>什么是命名空间</h2><p>在单个 k8s 集群中可以创建多个命名空间（namespace），它们在逻辑上彼此隔离，相当于在一个集群中创建了多个虚拟集群。</p><p>命名空间用于分组管理 k8s 集群中的资源对象，每一个添加到 k8s 集群的工作负载（workload）都必须放在一个命名空间中。</p><p>单个命名空间中的同类资源的名称必须唯一，但是相同的名称可以在不同的命名空间中使用。另外你还可以通过定义 ResourceQuota 对象来限制指定命名空间下资源的使用，利用 RBAC 来控制命名空间下的访问权限。</p><h2 id="为什么需要命名空间"><a href="#为什么需要命名空间" class="headerlink" title="为什么需要命名空间"></a>为什么需要命名空间</h2><p>使用单个命名空间对于小团队来说会很方便，但是对于大型团队或大型组织来说，拥有多个名称空间有很多好处，包括：</p><ul><li><p><code>隔离</code>：使用命名空间可以把多个团队或多个项目隔离到不同的环境中，不同的团队可以在不同的命名空间中使用相同的资源名称，对一个命名空间执行的操作也不会影响到其他命名空间。</p></li><li><p><code>资源控制</code>：可以通过资源配额来限制单个命名空间可使用的 CPU 和内存资源，这样可以确保每个团队或项目都具有运行所需的资源，并且不会占用所有的可用资源。</p></li><li><p><code>权限控制</code>：可以通过 RBAC 来定义角色和权限，这样可以确保只有授权用户才能访问给定命名空间中的资源。 </p></li><li><p><code>性能</code>：使用命名空间可以提高集群的性能，划分多个命名空间后，每个命名空间下的资源相比使用单个命名空间就会少很多，那么 k8s api 操作的对象集合就会少很多，从而减少 k8s api 的延迟。</p></li></ul><h2 id="初始命名空间"><a href="#初始命名空间" class="headerlink" title="初始命名空间"></a>初始命名空间</h2><p>k8s 初始会创建四个命名空间：</p><ul><li><p><code>default</code>：默认命名空间，如果你创建的资源没有指定命名空间，就会放在这个命名空间下。一般在正式环境不建议把服务部署到这个命名空间，因为这个命名空间下的资源会很混乱而且很难清理。</p></li><li><p><code>kube-system</code>：k8s 系统组件使用的命名空间，例如 <code>apiserver</code>、<code>scheduler</code>、<code>controller-manager</code> 等组件就在这个命名空间。一般情况下，我们应该避免使用这个命名空间，任何对这个命名空间的部署都可能是危险的操作。</p></li><li><p><code>kube-public</code>：用来存放公共资源的命名空间，主要是由 k8s 自己管理。</p></li><li><p><code>kube-node-lease</code>：用来存放与节点相关的租期（Lease）对象，该对象用来提升大规模集群下节点心跳检测的性能。</p></li></ul><p>虽然你可以把服务部署到这些初始创建的命名空间，但还是推荐单独创建你自己的命名空间来管理你的服务和资源，避免对这些初始命名空间的操作影响到整个集群。另外也不推荐将服务部署到 <code>default</code> 命名空间，因为你一不小心可能就把资源创建到了这个命名空间，导致这个命名空间下遗留了大量无用的资源，并且不好清理，在平时测试 k8s 功能或者 demo 的时候倒是可以使用 <code>default</code> 命名空间。</p><h2 id="命名空间的操作"><a href="#命名空间的操作" class="headerlink" title="命名空间的操作"></a>命名空间的操作</h2><h3 id="查看命名空间"><a href="#查看命名空间" class="headerlink" title="查看命名空间"></a>查看命名空间</h3><p>显示集群中所有的命名空间：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get namespace</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   27d</span><br><span class="line">kube-node-lease   Active   27d</span><br><span class="line">kube-public       Active   27d</span><br><span class="line">kube-system       Active   27d</span><br></pre></td></tr></table></figure><blockquote><p>kubectl 命令中的 <code>namespace</code> 可以缩写成 <code>ns</code>，所以可以使用 <code>kubectl get ns</code> 少打几个字符，这里为了展示就不用缩写了。</p></blockquote><p>命名空间包含 <code>Active</code> 和 <code>Terminating</code> 两种状态。<code>Active</code> 表示命名空间正在被使用中，<code>Terminating</code> 表示命名空间正在被删除。</p><p>查询指定命令空间下的 pod（<code>--namespace</code> 可以缩写成 <code>-n</code>）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pod --namespace default</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-7b9c8ddb75-pctld          1/1     Running   0          2d22h</span><br></pre></td></tr></table></figure><h3 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h3><p>使用命令创建命名空间：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl create namespace demo</span><br></pre></td></tr></table></figure><p>也可以使用 yaml 来创建：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo-namespace.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f demo-namespace.yaml</span><br></pre></td></tr></table></figure><h3 id="删除命名空间"><a href="#删除命名空间" class="headerlink" title="删除命名空间"></a>删除命名空间</h3><p>删除一个命名空间：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl delete namespace demo</span><br></pre></td></tr></table></figure><p>要注意的是，删除一个命名空间后，会自动删除该命名空间的下的所有资源，所以一定要小心使用。在删除命名空间之前，最好先使用 <code>kubectl get all -n &lt;namespace&gt;</code> 列出命名空间下的相关资源，确定资源都是可删除的，再进行删除操作。</p><p>初始创建的 <code>default</code>、<code>kube-system</code>、<code>kube-public</code> 命名空间是不可删除的。</p><h2 id="跨命名空间通信"><a href="#跨命名空间通信" class="headerlink" title="跨命名空间通信"></a>跨命名空间通信</h2><p>k8s 命名空间虽然资源隔离，但是一个命名空间中的服务还是可以与另一个命名空间中的服务进行通信的。这是很常见的需求，例如 A 团队（A 命名空间）的服务要访问 B 团队（B 命名空间）的服务。</p><p>如果你创建了一个 k8s service，k8s 就会创建一个对应的 dns 条目：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure><p>比如我在 <code>team-a</code> 命名空间下创建了名为 <code>user</code> 的 k8s service，那么对应 dns 名称就是：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user.team-a.svc.cluster.local</span><br></pre></td></tr></table></figure><p>在同一个命名空间下，可以通过 k8s service 的名称直接访问到对应服务，比如在 <code>team-a</code> 命名空间下的其他服务要访问 <code>user</code> 服务，<code>user</code> 服务暴露的端口是 8080，那么通过 <code>user:8080</code> 就能找到 <code>user</code> 服务，dns 会自动解析为完整地址 <code>user.team-a.svc.cluster.local</code>。</p><p>但是，如果是不同命名空间下的服务要相互访问，则需使用 k8 service 名称加上命名空间名称。比如在 <code>team-b</code> 命名空间访问 <code>team-a</code> 命名空间的 <code>user</code> 服务，就要使用 <code>user.team-a:8080</code> 地址来访问。</p><h2 id="命名空间划分策略"><a href="#命名空间划分策略" class="headerlink" title="命名空间划分策略"></a>命名空间划分策略</h2><p>不同的团队和组织可以采用不同的命名空间策略，具体取决于团队规模，组织结构，以及项目的复杂性等因素。一般有下面几种划分策略：</p><ul><li><p>根据团队或项目划分</p><p>对于服务较少的小团队来说，使用单个命名空间就足够了。对于大型团队或大型项目来说，为每个单独的团队或项目创建一个命名空间，可以很好进行管理，并利用前面我们提到的命名空间的优点。</p><p>例如：<code>team-a</code>、<code>team-b</code></p></li><li><p>根据开发环境划分</p><p>对于较小的团队或项目来说，命名空间很适合用来在集群中划分测试、预发布以及生成环境。但是通常情况下，建议用完全独立的集群区分不同的开发环境，以确保最大程度的隔离。</p><p>例如：<code>dev</code>、<code>stage</code>、<code>prod</code></p></li><li><p>根据服务层级划分</p><p>后台服务可能分为多个层级，比如有聚合服务、业务逻辑服务、通用组件或中台服务等，不同层级的服务可能使用不同的协议，有不同的访问策略，并且可能重名，那么根据命名空间来划分就可以很方便地做一些区分管理。</p><p>例如：<code>interface</code>、<code>service</code>、<code>infra</code></p></li></ul><!-- ## 命名空间实践我们团队在使用 k8s 时，结合当前的项目、团队、服务层级，创建了多个命名空间：- `wesing-wns`：wns 团队使用- `wesing-web`：web 团队使用- `wesing-interface`：后台聚合服务层- `wesing-service`：后台业务服务- `wesing-infra`：后台中台服务或通用组件由于我们的 k8s 集群已经区分了测试集群和正式集群，所以不需要用命名空间来区分环境。加项目前缀（`wesing-`）一方面是参考了 k8s 里命名空间的命名规范（`kube-public`、`kube-system`），另一方面是考虑到多个项目可能会部署在同一集群，加上项目前缀能做一定的区分。整体上符合我们当前的服务架构：![](image/2021-01-10-18-38-43.png) --><h2 id="命名空间使用技巧"><a href="#命名空间使用技巧" class="headerlink" title="命名空间使用技巧"></a>命名空间使用技巧</h2><p>使用 <code>kubectl config</code> 可以设置当前的命名空间的上下文，后续操作就不需要指定命名空间了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-context --current --namespace=&lt;命名空间名称&gt;</span><br></pre></td></tr></table></figure><p>也可以使用开源的 <a href="https://github.com/ahmetb/kubectx" target="_blank" rel="noopener">kubectx</a> 里的 <code>kubens</code> 工具，可以更方便地切换命名空间：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubens kube-system</span><br><span class="line">Context <span class="string">"test"</span> <span class="built_in">set</span>.</span><br><span class="line">Active namespace is <span class="string">"kube-system"</span>.</span><br><span class="line"></span><br><span class="line">$ kubens -</span><br><span class="line">Context <span class="string">"test"</span> <span class="built_in">set</span>.</span><br><span class="line">Active namespace is <span class="string">"default"</span>.</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 k8s 命名空间的概念以及使用方法，命名空间是一个非常简单又重要的概念，可以帮助团队更好的管理集群资源，熟悉命名空间的优点和特性可以帮助你更有效地配置集群，以避免后续带来的麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;什么是命名空间&quot;&gt;&lt;a href=&quot;#什么是命名空间&quot; class=&quot;headerlink&quot; title=&quot;什么是命名空间&quot;&gt;&lt;/a&gt;什么是命名空间&lt;/h2&gt;&lt;p&gt;在单个 k8s 集群中可以创建多个命名空间（namespace）
      
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Kubernetes" scheme="http://lujianan.com/tags/Kubernetes/"/>
    
      <category term="Namespace" scheme="http://lujianan.com/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>如何更优雅地切换 Git 分支</title>
    <link href="http://lujianan.com/2019/02/01/how-to-switch-git-branches-more-gracefully/"/>
    <id>http://lujianan.com/2019/02/01/how-to-switch-git-branches-more-gracefully/</id>
    <published>2019-02-01T06:04:41.000Z</published>
    <updated>2021-01-03T16:12:35.968Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，我们经常需要在不同的 Git 分支之间来回切换，特别是业务需求比较多的开发人员。在分支较多的情况下，分支名的 tab 自动补全会比较糟糕，切换时我们不免需要复制或手打分支名，那么有没有更优雅的方式了呢？</p><a id="more"></a><p>为了提高切换 Git 分支的效率，我用 Golang 写了 <code>git-checkout-branch</code> 这个小工具，可以交互式的切换分支，并自带搜索功能，帮助你更优雅的进行分支切换。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Github 地址：<a href="https://github.com/royeo/git-checkout-branch" target="_blank" rel="noopener">https://github.com/royeo/git-checkout-branch</a> ，欢迎 star。</p><p><img src="https://raw.githubusercontent.com/royeo/static/master/gif/git-checkout-branch.gif" alt></p><p>说明：</p><ul><li>使用箭头键  <code>↓</code> <code>↑</code> <code>→</code> <code>←</code> 进行移动，也支持 <code>j</code> 和 <code>k</code> 的上下移动</li><li>使用 <code>/</code> 切换搜索</li><li>按 <code>ctrl + c</code> 退出</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接下载安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -sSL https://github.com/royeo/git-checkout-branch/releases/download/v0.2.0/git-checkout-branch-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/git-checkout-branch &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/git-checkout-branch</span><br></pre></td></tr></table></figure><p>也可以使用 <code>go get</code> 安装，确保 <code>$GOPATH/bin</code> 路径在 <code>PATH</code> 中。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get -u github.com/royeo/git-checkout-branch</span><br></pre></td></tr></table></figure><p>建议为 <code>checkout-branch</code> 设置别名，例如 <code>cb</code>，这样就可以直接使用 <code>git cb</code> 来进行分支切换。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global alias.cb checkout-branch</span><br></pre></td></tr></table></figure><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>使用 <code>git checkout-branch help</code> 获取帮助信息。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Checkout git branches more efficiently.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  git checkout-branch [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -a, --all          List both remote-tracking branches and <span class="built_in">local</span> branches</span><br><span class="line">  -r, --remotes      List the remote-tracking branches</span><br><span class="line">  -n, --number       Set the number of branches displayed <span class="keyword">in</span> the list (default 10)</span><br><span class="line">      --hide-help    Hide the <span class="built_in">help</span> information</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中，我们经常需要在不同的 Git 分支之间来回切换，特别是业务需求比较多的开发人员。在分支较多的情况下，分支名的 tab 自动补全会比较糟糕，切换时我们不免需要复制或手打分支名，那么有没有更优雅的方式了呢？&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Golang" scheme="http://lujianan.com/tags/Golang/"/>
    
      <category term="Git" scheme="http://lujianan.com/tags/Git/"/>
    
      <category term="Tool" scheme="http://lujianan.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>Golang 标准库 log 包</title>
    <link href="http://lujianan.com/2019/01/18/golang-standard-library-log/"/>
    <id>http://lujianan.com/2019/01/18/golang-standard-library-log/</id>
    <published>2019-01-18T02:06:54.000Z</published>
    <updated>2021-01-03T18:28:01.856Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>Golang 标准库提供了一个简单的 log 包，方便我们记录日志。在平时写一些 demo 或小程序时，我们经常会用到 log 包，不过由于缺少结构化格式、日志级别等支持，在实际开发中则很少使用。log 包的设计非常简洁，造轮子之前可以参考下。</p><a id="more"></a><h2 id="日志设计"><a href="#日志设计" class="headerlink" title="日志设计"></a>日志设计</h2><p>一个简单的日志包应该有哪些功能呢？很容易想到以下几个：</p><ul><li>可设置日志的输出目标</li><li>可设置日志的固定输出项</li><li>日志输出接收可变参数</li><li>输出日志时并发安全</li></ul><p>所以标准库的 log 里设计了下面这样一个 <code>Logger</code> 结构体：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">mu     sync.Mutex <span class="comment">// ensures atomic writes; protects the following fields</span></span><br><span class="line">prefix <span class="keyword">string</span>     <span class="comment">// prefix on each line to identify the logger (but see Lmsgprefix)</span></span><br><span class="line">flag   <span class="keyword">int</span>        <span class="comment">// properties</span></span><br><span class="line">out    io.Writer  <span class="comment">// destination for output</span></span><br><span class="line">buf    []<span class="keyword">byte</span>     <span class="comment">// for accumulating text to write</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>mu</code> 是一个 <code>sync.Mutex</code> 互斥锁，用来在高并发或多协程的情况下保护上下文数据一致。在结构体里把 <code>sync.Mutex</code> 属性的字段放在要保护的字段前面，也是 go 里面常见的风格。</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">SetOutput</span><span class="params">(w io.Writer)</span></span> &#123;</span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line">l.out = w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>prefix</code> 用来设置固定的日志前缀，设置的内容会出现在每行日志的最开头。</p></li><li><p><code>flag</code> 用来设置跟在 <code>prefix</code> 后打印的一些日志属性，如日期、时间、文件名和行号等。<code>flag</code> 通过按位或（<code>|</code>）的方式来设置多个属性，可设置的属性如下：</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// the date in the local time zone: 2009/01/23</span></span><br><span class="line">Ltime                         <span class="comment">// the time in the local time zone: 01:23:23</span></span><br><span class="line">Lmicroseconds                 <span class="comment">// microsecond resolution: 01:23:23.123123.  assumes Ltime.</span></span><br><span class="line">Llongfile                     <span class="comment">// full file name and line number: /a/b/c/d.go:23</span></span><br><span class="line">Lshortfile                    <span class="comment">// final file name element and line number: d.go:23. overrides Llongfile</span></span><br><span class="line">LUTC                          <span class="comment">// if Ldate or Ltime is set, use UTC rather than the local time zone</span></span><br><span class="line">Lmsgprefix                    <span class="comment">// move the "prefix" from the beginning of the line to before the message</span></span><br><span class="line">LstdFlags     = Ldate | Ltime <span class="comment">// initial values for the standard logger</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>out</code> 属性是日志的输出目标，在 go 里很自然的可以想到使用 <code>io.Writer</code> 接口，与具体实现分离开。默认开箱即用的 <code>out</code> 是标准输出，可以用 <code>log.SetOutput</code> 或 <code>log.New</code> 来设置一个文件输出。</p></li><li><p><code>buf</code> 是日志内容的缓冲区，为了避免每次写入都需要分配内存，所有日志的写入都共用一个缓冲区。</p></li></ul><h2 id="日志操作"><a href="#日志操作" class="headerlink" title="日志操作"></a>日志操作</h2><p>使用 log 包写日志的操作很简单，提供了开箱即用的 <code>log.Println</code>，<code>log.Printf</code> 等函数，这些函数会调用内部私有变量 <code>std</code> 的方法，<code>std</code> 是 <code>Logger</code> 结构体的一个实例，输出日志到 <code>stderr</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">""</span>, LstdFlags)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">std.Output(<span class="number">2</span>, fmt.Sprintln(v...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>log.Println</code> 实际调用了 <code>Logger</code> 的 <code>Output</code> 方法，该方法接收两个参数，一个是函数调用深度，一个是日志内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">Output</span><span class="params">(calldepth <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">now := time.Now() <span class="comment">// get this early.</span></span><br><span class="line"><span class="keyword">var</span> file <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> line <span class="keyword">int</span></span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;(Lshortfile|Llongfile) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Release lock while getting caller info - it's expensive.</span></span><br><span class="line">l.mu.Unlock()</span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">_, file, line, ok = runtime.Caller(calldepth)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">file = <span class="string">"???"</span></span><br><span class="line">line = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">l.mu.Lock()</span><br><span class="line">&#125;</span><br><span class="line">l.buf = l.buf[:<span class="number">0</span>]</span><br><span class="line">l.formatHeader(&amp;l.buf, now, file, line)</span><br><span class="line">l.buf = <span class="built_in">append</span>(l.buf, s...)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || s[<span class="built_in">len</span>(s)<span class="number">-1</span>] != <span class="string">'\n'</span> &#123;</span><br><span class="line">l.buf = <span class="built_in">append</span>(l.buf, <span class="string">'\n'</span>)</span><br><span class="line">&#125;</span><br><span class="line">_, err := l.out.Write(l.buf)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Output</code> 方法会进行加锁操作，因为日志的 buf 是共享的，不是每条日志一个 buf，所以需要用锁来保护好 buf，实现串行写入。所以如果你的日志疯狂输出，大量的加锁操作 syscall 对性能就会有很大影响。另外思考一个问题，写日志的时候是不是一定要加锁呢？正常情况下，单纯的写日志是不需要加锁的，因为写日志可以采用文件的 <code>O_APPEND</code> 模式，原子方式一直追加。</p><p>在 <code>Output</code> 方法里，如果 <code>flag</code> 设置了 <code>Lshortfile</code> 或 <code>Llongfile</code> 属性，<code>Output</code> 方法会调用 <code>runtime.Caller</code> 来获取打印日志操作所在的文件名和行号。<code>calldepth</code> 参数用来指定函数调用深度，调用链为：<code>log.Println</code> -&gt; <code>std.Output</code> -&gt; <code>runtime.Caller</code>，所以调用深度为2。注意这里在获取文件名和行号的时候，释放了互斥锁，原因是 <code>runtime.Caller</code> 可能会比较耗时。因为 <code>runtime.Caller</code> 会不停地迭代，而这个迭代过程虽然单次消耗的时间可以忽略不计，但是对于日志量巨大的服务而言影响还是很大的。</p><p>写入的时候，就是先清空 <code>buf</code>，接着对 <code>prefix</code> 和 <code>flag</code> 进行处理（<code>l.formatHeader</code>）并存入 <code>buf</code>，然后将日志内容也追加到 <code>buf</code> 中，最后调用 <code>out</code> 属性的 <code>Write</code> 方法输出日志。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>整个 log 包就 300 多行代码，功能非常简单，使用起来也很方便。对于标准库来说，考虑的更多的是简洁、通用，而对于后端服务来说，则需要考虑更多的东西，比如结构化日志、性能问题等。一般情况下，不建议在生产环境使用标准库的 log 包来输出日志。目前 Golang 有很多优秀的开源日志库，例如：<code>zap</code>、<code>gokit/log</code>、<code>logrus</code> 等，各有各的优势，我们可以针对不同场景选择不同的日志库来解决问题，或者自行造轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;Golang 标准库提供了一个简单的 log 包，方便我们记录日志。在平时写一些 demo 或小程序时，我们经常会用到 log 包，不过由于缺少结构化格式、日志级别等支持，在实际开发中则很少使用。log 包的设计非常简洁，造轮子之前可以参考下。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Golang" scheme="http://lujianan.com/tags/Golang/"/>
    
      <category term="Log" scheme="http://lujianan.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab 搭建与 CI 配置</title>
    <link href="http://lujianan.com/2018/11/10/gitlab-build/"/>
    <id>http://lujianan.com/2018/11/10/gitlab-build/</id>
    <published>2018-11-10T09:21:57.000Z</published>
    <updated>2021-01-03T16:12:35.967Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一个独立开发的 Golang 微服务需要上线，项目托管在内部的 GitLab 上，所以需要写一个 .gitlab-ci.yml 文件来走 CI。由于之前一直是在比较成熟的团队中，没有自己写过 GitLab 的 CI 配置，所以索性尝试下自己搭建 GitLab，然后配置一套 CI 来熟悉下。</p><a id="more"></a><h2 id="搭建-GitLab"><a href="#搭建-GitLab" class="headerlink" title="搭建 GitLab"></a>搭建 GitLab</h2><p>搭建 GitLab 最简单的方式当然是使用 docker。GitLab 的 docker 镜像集成了 GitLab 在运行中需要的所有服务。</p><p>这里使用 docker-compose 来运行，方便修改参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">web:</span><br><span class="line">  image: <span class="string">'gitlab/gitlab-ce:latest'</span></span><br><span class="line">  restart: always</span><br><span class="line">  hostname: <span class="string">'gitlab.example.com'</span></span><br><span class="line">  environment:</span><br><span class="line">    GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">      external_url <span class="string">'https://gitlab.example.com'</span></span><br><span class="line">      <span class="comment"># Add any other gitlab.rb configuration here, each on its own line</span></span><br><span class="line">  ports:</span><br><span class="line">    - <span class="string">'80:80'</span></span><br><span class="line">    - <span class="string">'443:443'</span></span><br><span class="line">    - <span class="string">'22:22'</span></span><br><span class="line">  volumes:</span><br><span class="line">    - <span class="string">'/srv/gitlab/config:/etc/gitlab'</span></span><br><span class="line">    - <span class="string">'/srv/gitlab/logs:/var/log/gitlab'</span></span><br><span class="line">    - <span class="string">'/srv/gitlab/data:/var/opt/gitlab'</span></span><br></pre></td></tr></table></figure><p>这里需要注意 SSH、HTTP、HTTPS 的端口是否被占用，以及卷的位置 docker 是否有权限访问。例如，在 macOS 上，docker 没有 /srv 的权限，所以可以使用 /Users/Shared 目录替代 /srv。</p><p>在容器启动后，等 GitLab 初始化完成（需等待一会），就可以通过  <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 访问了。</p><p>另外还有一些部署 GitLab 的方法，具体参考官方文档：<a href="https://docs.gitlab.com/omnibus/README.html" target="_blank" rel="noopener">Omnibus GitLab documentation</a>。</p><h2 id="配置-GitLab"><a href="#配置-GitLab" class="headerlink" title="配置 GitLab"></a>配置 GitLab</h2><p>GitLab 的所有配置都在 /etc/gitlab/gitlab.rb 文件中，你可以在 docker 挂载的数据卷目录下去修改配置，也可以进入 docker 容器去修改：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab /bin/bash</span><br></pre></td></tr></table></figure><p>在 GitLab 的配置中，你需要修改 external_url 配置项为一个有效的 url，这个 url 就是你的 GitLab 仓库的域名，也可以通过上面 docker-compose 文件中的 environment 来修改 external_url 配置项。没有域名的话可以先用 IP 地址。</p><p>还有很多其他的配置，如邮箱、HTTPS 等的配置就不多介绍了。详细配置参考官方文档：<a href="https://docs.gitlab.com/omnibus/settings/configuration.html" target="_blank" rel="noopener">Configuration options</a>。</p><p>在修改完配置后，需要重启 docker 容器：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure><h2 id="搭建-GitLab-Runner"><a href="#搭建-GitLab-Runner" class="headerlink" title="搭建 GitLab Runner"></a>搭建 GitLab Runner</h2><p>GitLab 的 CI 需要安装 Gitlab Runner，Runner 负责运行 .gitlab-ci.yml 中定义的 job，并且将结果发送回 GitLab。</p><p>Runner 不建议和 GitLab 同时运行在一台机器上，因为 Runner 很消耗资源，一旦 CI 运行起来，就可以看到 Runner 的 CPU 使用率飙升，所以应该分开部署。如果只是想测试一下，也可以先在一台机器上试一下。</p><p>同样使用 docker 来运行 Runner：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">-v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure><p>然后需要把 Runner 注册到刚刚搭建好的 GitLab 上：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --rm -t -i -v /srv/gitlab-runner/config:/etc/gitlab-runner --name gitlab-runner gitlab/gitlab-runner register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor <span class="string">"docker"</span> \</span><br><span class="line">  --docker-image alpine:3.7 \</span><br><span class="line">  --url <span class="string">"https://gitlab.com/"</span> \</span><br><span class="line">  --registration-token <span class="string">"PROJECT_REGISTRATION_TOKEN"</span> \</span><br><span class="line">  --description <span class="string">"docker-runner"</span> \</span><br><span class="line">  --tag-list <span class="string">"docker,aws"</span> \</span><br><span class="line">  --run-untagged \</span><br><span class="line">  --locked=<span class="string">"false"</span></span><br></pre></td></tr></table></figure><p>注册参数说明：</p><ul><li><p>–url：</p><p>  GitLab 的域名，如果还没有配置域名的话，可以先使用 IP 地址代替。</p></li><li><p>–registration-token：</p><p>  CI 的 token，需要从 GitLab 页面上获取，参考：<a href="https://docs.gitlab.com/ee/ci/runners/" target="_blank" rel="noopener">Obtain a token</a>。</p></li><li><p>–description</p><p>  Runner 的描述，稍后可以在 GitLab 的页面 Settings &gt; CI/CD &gt; Runners 那里看到该 Runner 的描述。</p></li><li><p>–tag-list</p><p>  Runner 的 tags，使用 tag 标记 Runner 后，在 .gitlab-ci.yml 中定义 job 时，就可以使用 tags 配置来指定运行这个 job 的 Runner。</p></li><li><p>–executor</p><p>  Runner 的执行器，推荐使用 docker，它拥有一个干净的构建环境，易于依赖管理。</p></li><li><p>–docker-image</p><p>  如果你使用 docker 作为 executor，需要提供一个默认镜像，在 .gitlab-ci.yml 中没有定义镜像时使用。</p></li></ul><h2 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h2><p>在搭建好 GitLab 和 Runner 后，就可以在 GitLab 上新建一个项目，然后写 CI 的配置文件 .gitlab-ci.yml 了，参考：<a href="https://docs.gitlab.com/ee/ci/yaml/README.html" target="_blank" rel="noopener">Configuring .gitlab-ci.yml</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一个独立开发的 Golang 微服务需要上线，项目托管在内部的 GitLab 上，所以需要写一个 .gitlab-ci.yml 文件来走 CI。由于之前一直是在比较成熟的团队中，没有自己写过 GitLab 的 CI 配置，所以索性尝试下自己搭建 GitLab，然后配置一套 CI 来熟悉下。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Golang" scheme="http://lujianan.com/tags/Golang/"/>
    
      <category term="Gitlab" scheme="http://lujianan.com/tags/Gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 代码高亮的标记大全</title>
    <link href="http://lujianan.com/2018/10/30/markdown-syntax-highlight/"/>
    <id>http://lujianan.com/2018/10/30/markdown-syntax-highlight/</id>
    <published>2018-10-30T13:43:37.000Z</published>
    <updated>2021-01-03T16:12:35.969Z</updated>
    
    <content type="html"><![CDATA[<p>用 markdown 写文档的话经常会用到代码的语法高亮，这里列出了常用的语法高亮标签，前面是标签，括号里是对应的文件扩展名。</p><a id="more"></a><h2 id="Syntax-Highlight"><a href="#Syntax-Highlight" class="headerlink" title="Syntax Highlight"></a>Syntax Highlight</h2><ul><li>Cucumber (‘*.feature’)</li><li>abap (‘*.abap’)</li><li>ada (‘.adb’, ‘.ads’, ‘*.ada’)</li><li>ahk (‘.ahk’, ‘.ahkl’)</li><li>apacheconf (‘.htaccess’, ‘apache.conf’, ‘apache2.conf’)</li><li>applescript (‘*.applescript’)</li><li>as (‘*.as’)</li><li>as3 (‘*.as’)</li><li>asy (‘*.asy’)</li><li>bash (‘.sh’, ‘.ksh’, ‘.bash’, ‘.ebuild’, ‘*.eclass’)</li><li>bat (‘.bat’, ‘.cmd’)</li><li>befunge (‘*.befunge’)</li><li>blitzmax (‘*.bmx’)</li><li>boo (‘*.boo’)</li><li>brainfuck (‘.bf’, ‘.b’)</li><li>c (‘.c’, ‘.h’)</li><li>cfm (‘.cfm’, ‘.cfml’, ‘*.cfc’)</li><li>cheetah (‘.tmpl’, ‘.spt’)</li><li>cl (‘.cl’, ‘.lisp’, ‘*.el’)</li><li>clojure (‘.clj’, ‘.cljs’)</li><li>cmake (‘*.cmake’, ‘CMakeLists.txt’)</li><li>coffeescript (‘*.coffee’)</li><li>console (‘*.sh-session’)</li><li>control (‘control’)</li><li>cpp (‘.cpp’, ‘.hpp’, ‘.c++’, ‘.h++’, ‘.cc’, ‘.hh’, ‘.cxx’, ‘.hxx’, ‘*.pde’)</li><li>csharp (‘*.cs’)</li><li>css (‘*.css’)</li><li>cython (‘.pyx’, ‘.pxd’, ‘*.pxi’)</li><li>d (‘.d’, ‘.di’)</li><li>delphi (‘*.pas’)</li><li>diff (‘.diff’, ‘.patch’)</li><li>dpatch (‘.dpatch’, ‘.darcspatch’)</li><li>duel (‘.duel’, ‘.jbst’)</li><li>dylan (‘.dylan’, ‘.dyl’)</li><li>erb (‘*.erb’)</li><li>erl (‘*.erl-sh’)</li><li>erlang (‘.erl’, ‘.hrl’)</li><li>evoque (‘*.evoque’)</li><li>factor (‘*.factor’)</li><li>felix (‘.flx’, ‘.flxh’)</li><li>fortran (‘.f’, ‘.f90’)</li><li>gas (‘.s’, ‘.S’)</li><li>genshi (‘*.kid’)</li><li>glsl (‘.vert’, ‘.frag’, ‘*.geo’)</li><li>gnuplot (‘.plot’, ‘.plt’)</li><li>go (‘*.go’)</li><li>groff (‘.(1234567)’, ‘.man’)</li><li>haml (‘*.haml’)</li><li>haskell (‘*.hs’)</li><li>html (‘.html’, ‘.htm’, ‘.xhtml’, ‘.xslt’)</li><li>hx (‘*.hx’)</li><li>hybris (‘.hy’, ‘.hyb’)</li><li>ini (‘.ini’, ‘.cfg’)</li><li>io (‘*.io’)</li><li>ioke (‘*.ik’)</li><li>irc (‘*.weechatlog’)</li><li>jade (‘*.jade’)</li><li>java (‘*.java’)</li><li>js (‘*.js’)</li><li>jsp (‘*.jsp’)</li><li>lhs (‘*.lhs’)</li><li>llvm (‘*.ll’)</li><li>logtalk (‘*.lgt’)</li><li>lua (‘.lua’, ‘.wlua’)</li><li>make (‘.mak’, ‘Makefile’, ‘makefile’, ‘Makefile.‘, ‘GNUmakefile’)</li><li>mako (‘*.mao’)</li><li>maql (‘*.maql’)</li><li>mason (‘.mhtml’, ‘.mc’, ‘*.mi’, ‘autohandler’, ‘dhandler’)</li><li>markdown (‘*.md’)</li><li>modelica (‘*.mo’)</li><li>modula2 (‘.def’, ‘.mod’)</li><li>moocode (‘*.moo’)</li><li>mupad (‘*.mu’)</li><li>mxml (‘*.mxml’)</li><li>myghty (‘*.myt’, ‘autodelegate’)</li><li>nasm (‘.asm’, ‘.ASM’)</li><li>newspeak (‘*.ns2’)</li><li>objdump (‘*.objdump’)</li><li>objectivec (‘*.m’)</li><li>objectivej (‘*.j’)</li><li>ocaml (‘.ml’, ‘.mli’, ‘.mll’, ‘.mly’)</li><li>ooc (‘*.ooc’)</li><li>perl (‘.pl’, ‘.pm’)</li><li>php (‘.php’, ‘.php(345)’)</li><li>postscript (‘.ps’, ‘.eps’)</li><li>pot (‘.pot’, ‘.po’)</li><li>pov (‘.pov’, ‘.inc’)</li><li>prolog (‘.prolog’, ‘.pro’, ‘*.pl’)</li><li>properties (‘*.properties’)</li><li>protobuf (‘*.proto’)</li><li>py3tb (‘*.py3tb’)</li><li>pytb (‘*.pytb’)</li><li>python (‘.py’, ‘.pyw’, ‘.sc’, ‘SConstruct’, ‘SConscript’, ‘.tac’)</li><li>rb (‘.rb’, ‘.rbw’, ‘Rakefile’, ‘.rake’, ‘.gemspec’, ‘.rbx’, ‘.duby’)</li><li>rconsole (‘*.Rout’)</li><li>rebol (‘.r’, ‘.r3’)</li><li>redcode (‘*.cw’)</li><li>rhtml (‘*.rhtml’)</li><li>rst (‘.rst’, ‘.rest’)</li><li>sass (‘*.sass’)</li><li>scala (‘*.scala’)</li><li>scaml (‘*.scaml’)</li><li>scheme (‘*.scm’)</li><li>scss (‘*.scss’)</li><li>smalltalk (‘*.st’)</li><li>smarty (‘*.tpl’)</li><li>sourceslist (‘sources.list’)</li><li>splus (‘.S’, ‘.R’)</li><li>sql (‘*.sql’)</li><li>sqlite3 (‘*.sqlite3-console’)</li><li>squidconf (‘squid.conf’)</li><li>ssp (‘*.ssp’)</li><li>tcl (‘*.tcl’)</li><li>tcsh (‘.tcsh’, ‘.csh’)</li><li>tex (‘.tex’, ‘.aux’, ‘*.toc’)</li><li>text (‘*.txt’)</li><li>v (‘.v’, ‘.sv’)</li><li>vala (‘.vala’, ‘.vapi’)</li><li>vbnet (‘.vb’, ‘.bas’)</li><li>velocity (‘.vm’, ‘.fhtml’)</li><li>vim (‘*.vim’, ‘.vimrc’)</li><li>xml (‘.xml’, ‘.xsl’, ‘.rss’, ‘.xslt’, ‘.xsd’, ‘.wsdl’)</li><li>xquery (‘.xqy’, ‘.xquery’)</li><li>xslt (‘.xsl’, ‘.xslt’)</li><li>yaml (‘.yaml’, ‘.yml’)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 markdown 写文档的话经常会用到代码的语法高亮，这里列出了常用的语法高亮标签，前面是标签，括号里是对应的文件扩展名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="http://lujianan.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>《现代操作系统》第1章 习题</title>
    <link href="http://lujianan.com/2018/10/14/modern-operating-systems-c1-exercise/"/>
    <id>http://lujianan.com/2018/10/14/modern-operating-systems-c1-exercise/</id>
    <published>2018-10-14T02:16:26.000Z</published>
    <updated>2021-01-03T16:12:35.969Z</updated>
    
    <content type="html"><![CDATA[<p>1.什么是多道程序设计？</p><p>Multiprogramming is the rapid switching of the CPU between multiple processes in memory. It is commonly used to keep the CPU busy while one or more processes are doing I/O.</p><a id="more"></a><p>2.什么是SPOOLing？读者是否认为将来的高级个人计算机会把SPOOLing作为标准功能？</p><p>Input spooling is the technique of reading in jobs, for example, from cards, onto the disk, so that when the currently executing processes are finished, there will be work waiting for the CPU. Output spooling consists of first copying printable files to disk before printing them, rather than printing directly as the output is generated. Input spooling on a personal computer is not very likely, but output spooling is.</p><p>3.在早期计算机中，每个字节的读写直接由CPU处理（即没有DMA）。对于多道程序设计而言这种组织方式有什么含义？</p><p>The prime reason for multiprogramming is to give the CPU something to do while waiting for I/O to complete. If there is no DMA, the CPU is fully occupied doing I/O, so there is nothing to be gained (at least in terms of CPU utilization) by multiprogramming. No matter how much I/O a program does, the CPU will be 100% busy. This is of course assume the major delay is the wait while data are copied. A CPU could do other work if the I/O were slow for other reasons (arriving on serial line, for instance).</p><p>4.系列计算机的思想在20世纪60年代由IBM引入进System/360大型机。现在这种思想已经消亡还是继续活跃着？</p><p>It is still alive. For example, Intel makes Pentium I, II, and III, and 4 CPUs with a variety of different properites including spped and power consumption. All of these machines ar architecturally compatible. They differ only in price and perfermance, which is the essence of the family idea.</p><p>5.缓慢采用GUI的一个原因是支持它的硬件的成本（高昂）。为了支持25行80列字符的单色文本屏幕应该需要多少视频RAM？对于1024x768像素24位色彩位图需要多少视频RAM？在1989年（$5/KB）这些RAM的成本是多少？现在它的成本是多少？</p><p>A 25x80 character monochrome text screen requires a 2000-byte buffer. 2580=2000 The 1024x768 pixel 24-bit color bitmap requires 2359296 bytes. 102476824/8=2359296 In 1980 these two options would have cost $10 and $11520, respectively. 20005/1024=9.77 2359296*5/1024=11520 For current prices, check on how much RAM currently costs, probably less than $1/MB.</p><p>6.在建立一个操作系统时有几个设计目的，例如资源利用、及时性，健壮性等。请列举两个可能互相矛盾的设计目的。</p><p>Consider fairness and real time. Fairness requires that each process be allocated it resources in a fair way, with no process getting more than its fair share. On the other hand, real time requires that resources be allocated based on the times when different processes must complete their execution. A real time process may get a disproportionate share of the resources.</p><p>7.下面哪一条指令只能在内核态中使用？</p><p>a)禁止所有的中断。 b)读日期-时间时钟。 c)设置日期-时间时钟。 d)改变存储器映像。</p><p>acd</p><p>8.考虑一个有两个CPU的系统，并且每一个CPU有两个线程（超线程）。假设有三个程序P0,P1,P2，分别以运行时间5ms,10ms,20ms开始。运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻塞，并且一旦设定就不改变CPU。</p><p>It may take 20, 25, 30 or 35 msec to complete the execution of these programs depending on how the operating system schedules them. If P0 and P1 are scheduled on the same CPU and P2 is scheduled on the other CPU, it will take 20 mses. If P0 and P2 are scheduled on the same CPU and P1 is scheduled on the other CPU, it will take 25 msec. If P1 and P2 are scheduled on the same CPU and P0 is scheduled on the other CPU, it will take 30 msec. If all three are on the same CPU, it will take 35 msec.</p><p>9.一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns。这台机器每秒可执行多少条指令？</p><p>Every nanosecond one instruction emerges from the pipeline. This means the machine is executing 1 billion instructions per second. It does not matter at all how many stages the pipeline has. A 10-stage pipeline with 1 nsec per stage would also execute 1 billion instructions per second. All that matters is how often a finished instruction pops out the end of the pipeline.</p><p>10.假设一个计算机系统有高速缓存、内存（RAM）以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要2ns，RAM需要10ns，磁盘需要10ms。如果缓存的命中率是95%，内存的是（缓存失效）99%，读取一个词的平均时间是多少？</p><p>Average access time = 0.95 × 2 nsec (word is cache)</p><ul><li>0.05 × 0.99 × 10 nsec (word is in RAM, but not in cache)</li><li>0.05 × 0.01 × 10,000,000 nsec (word on disk only) = 5002.395 nsec = 5.002395 μsec</li></ul><p>11.一位校对人员注意到在一部将要出版的操作系统教科书手稿中有一个多次出现的拼写错误。这本书大致有700页。每页50行，一行80个字符。若把文稿用电子扫描，那么，主副本进入图1-9中的每个存储系统的层次要花费多少时间？对于内存储方式，考虑所给定的存取时间是每次一个1024字符的盘块，而对于磁带，假设给定开始时间后的存取时间和和磁盘存储时间相同。</p><p>The manuscript contains 80 X 50 X 700 = 2.8 million characters. This is, of course, impossible to fit into the registers of any currently available CPU and is too big for a 1-MB cache, but if such hardware were available, the manuscript could be scanned in 2.8 msec ( 2.8 X 10^6 X 10^-9 s) from the registers or 5.8 msec (2.8 X 10^6 X 2 X 10^-9 s) from the cache. There are approximately 2700 ( 2.8 X 10^6 % 1024 = 2735 ) 1024-byte blocks of data, so scanning from the disk would require about 27 seconds (2700 X 10 X 10^-3= 27s ), and from tape 2 minutes 7 senconds ( 100 + 27 = 127s tape不考虑读入时的文件大小？ ).</p><p>12.**在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？</p><p>Maybe. If the caller get control back and immediately overwrites the data, when the write finally occurs, the wrong data will be written. However, if the driver first copied the data to a private buffer before returning, then the caller can be allowed to continue immediately. Another possiblity is to allow the caller to continue and give it a singal when the buffer may be used, but this is tricky and error prone.</p><p>13.什么是陷阱指令？在操作系统中解释它的用途。</p><p>A trap instruction switches the execution mode of a CPU from the user mode to the kernel mode. This instruction allow a user program to invoke functions in the operation system kernel.</p><p>14.陷阱和中断的主要差别是什么？</p><p>A trap is caused by the program and is synchronous with it. If the program is run again and again, the trap will always occur exactly the same position in the instruction stream. An interrupt is caused by an external event and its timing is not reproducible.</p><p>15.在分时系统中为什么需要进程表？在只有一个进程存在的个人计算机系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？</p><p>The process table is needed to store the state of a process that is currently suspended, either ready or blocked. It is not needed in a single process system because the single process is never suspended.</p><p>16.说明有没有理由要在一个非空的目录中安装一个文件系统？如果要这样做，如何做？</p><p>Mounting a file system makes any files already in the mount point directory inaccessible, so mount points are normally empty. However, a system administrator might want to copy some of the most important files normally located in the mounted directory to the mount point so they could be found in their noraml path in an emergency when the mounted device was being repaired.</p><p>17.在一个操作系统中系统调用的目的是什么？</p><p>A system call allows a user process to access and execute operating system functions indside the kernel. User programs use system calls to invoke operating system services.</p><p>18.对于下列系统调用，给出引起失败的条件：fork、exec以及unlink。</p><p>Fork can fail if there are no free slot left in the process table (and possibley if there is no memory or swap space left). Exec can fail if the file name given does not exist or is not a valid executable file. Unlink can fail if the file to be unlinked does not exist or the calling process does not have authority to unlink it.</p><p>19.在count = write(fd, buffer, nbytes);调用中，能在count中而不是nbytes中返回值吗？如果能，为什么？</p><p>If the call fails, for example because fd is incorrect, it can return -1. It can also fail because the disk is full and it is not possible to write the number of bytes requested. On a correct termination, it always return nbytes.</p><p>20.有一个文件，其文件描述符是fd，内含字节序列：3,1,4,1,5,9,2,6,5,3,5。有如下系统调用：lseek(fd,3,SEEK_SET); read(fd,&amp;buffter,4); 其中lseek调用寻找文件中的字节3。在读操作完成后，buffer中的内容是什么？</p><p>It contains the bytes: 1, 5, 9, 2.</p><p>21.假设一个10MB的文件存在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第100号轨道。要想从磁盘上找回这个文件，需要多长时间？假设碰头臂从一个柱面移动到下一个柱面需要1ms，当文件的开始部分存储在的扇区旋转到磁头下需要5ms，并且读的速率是100MB/s。</p><p>(100-50)*1ms+5ms+10MB/100MB/s=55ms+0.1X10^3ms=155ms</p><p>Time to retrieve the file = 1 * 50 ms (Time to move the arm over track # 50)</p><ul><li>5 ms (Time for the first sector to rotate under the head)</li><li>10/100 * 1000 ms (Read 10 MB) = 155 ms</li></ul><p>22.块特殊文件和字符特殊文件的基本差别是什么？</p><p>Block special files consist of numbered blocks, each of which can be read or written independently of all the other ones. It is possible to seek to any block and start reading and writing. This is not possible with character specical files.</p><p>23.在图1-17的例子中库调用称为read，而系统调用自身称为read。这两者都有相同的名字是正常的吗？如果不是，哪一个更重要？</p><p>System calls do not really have names, other than in a documentation sence. When the libray procedure read traps to the kernel, it puts the number of the system call in a register ro on the stack. This number is used to index into a table. There is really no name used anywhere. On the other hand, the name of the library procedure is very import, since this is what appears in the program.</p><p>24.在分布式系统中，客户机-服务器模式很普遍。这种模式能用在单个计算机的系统中吗？</p><p>Yes it can, especially if the kernel is message-passing system.</p><p>25.对于程序员而言，系统调用就像对其他库过程的调用一样。有无必要让程序员了解哪一个库过程导致了系统调用？在什么情形下，为什么？</p><p>As far as program logic is concerned it does not matter whether a call to a library procedure results in a system call. But if perfermance is an issue, if a task can be accomplished without a system call the program will run faster. Every system call involves overhead time in switching from the user context to the kernel context. Furthermore, on a multiuser system the operatiing system may schedule another process o run when a system call completes, further slowing the progress in real time of a calling process.</p><p>26.图1-23说明有一批UNIX的系统调用没有与之相等价的Win32 API。对于所列出的每一个没有Win32等价的调用，若程序员要把一个UNIX程序转换到Windows下运行，会有什么后果？</p><p>Serval UNIX calls have no counterpart in the Win32 API: Link: a Win32 program cannot refer to a file by an alternative name or see it in more than one directory. Also, attempting to create a link is a convenient way to test fro and create a lock on a file. Mount and umount: a Windows program cannot make assumptions about standard path names because on systems with multiple disk drives the drive name part of the path may be different. Chmod: Windows uses access control lists Kill: Windows programmers cannot kill a misbehaving program that is not cooperating.</p><p>27.可移植的操作系统是能从一个系统体系结构到另一个体系结构的移动不需要任何修改的操作系统。请解释为什么建立一个完全可移植性的操作系统是不可行的。描述一下在设计一个高度可移植的操作系统时你设计的高级的两层是什么样的。</p><p>Every system architecture has its own set of instructions that it can execute. Thus a Pentumn cannot excute SPARC programs and SPARC cannot execute Pentium programs. Also, different architectures differ in bus architecture used (such as VME, ISA, PCI, MCA, SBus, ..) as well as the word size of the CPU (usually 32 or 64 bit). Because of these differences in hardware, it is not feasible to build an operating system that is completely portable. A highly portable operating system will consist of two high-level layers—a machine-dependent layer and a machine independent layer. The machine-dependent layer addresses the specifics of the hardware, and must be implemented separately for every architecture. This layer provides a uniform interface on which the machine-independent layer is built. The machine-independent layer has to be implemented only onece. To be highly protable, the size of the machine-dependent layer must be kept as small as possible.</p><p>28.请解释在建立基于微内核的操作系统时策略与机制的分离带来的好处。</p><p>Separation of policy and mechanism allows OS designers to implement a small number of basic primitives in the kernel. These primitives are simpified, because they are not dependent of any specific policy. They can then be used to implement more complex mechanisms and policies at the user level.</p><p>29.下面是单位转换的练习：</p><ul><li>a)一微年是多少秒？</li><li>b)微米常称为micron。那么gigamicron是多长？</li><li>c)1TB存储器有多少字节？</li><li>d)地球的质量是6000yottagram，换算成kilogram是多少？</li></ul><p>answers:</p><ul><li>a) A micro year is 10^-6 X 365 X 24 X 3600 = 31.536 sec.</li><li>b) 10^9*10^-6=1000m</li><li>c) 2^10 X 2^10 X 2^10 X 2^10 = 2^40 Bytes</li><li>d) 6000 X 10^24 X 10^-3 = 6 X 10^24 kilogram</li></ul><p>30.写一个各图1-19类似的shell，但是包含足够的实际可工作的代码，这样读者可以测试它。读者还可以添加某些功能，如输入输出重定向、管道以及后台作业等。</p><p>31.如果读者拥有一个个人UNIX类操作系统（Linux/MINIX/FreeBSD等），可以安全地崩溃和再启动，请写一个可以试图创建一个无限制数量子进程的shell脚本并观察所发生的事。在运行实验之前 ，通过shell键入sync，在磁盘上备份好文件缓冲区以避免毁坏文件系统。（注意：在没有得到系统管理呐的允许之前，不要在分时系统上进行这一尝试。其后果将会立即发生，尝试者可能会被抓住并受到惩罚。）</p><p>32.用一个类似于UNIX od或MS-DOS DEBUG的程序考察并尝试解释UNIX类系统或Windows的目录。提示：如何进行取决于OS允许做什么。一个有益的技巧是在一个有某个操作系统的软盘上创建一个目录，然后使用一个允许进行此类的访问的不同的操作系统读盘上的原始数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.什么是多道程序设计？&lt;/p&gt;
&lt;p&gt;Multiprogramming is the rapid switching of the CPU between multiple processes in memory. It is commonly used to keep the CPU busy while one or more processes are doing I/O.&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://lujianan.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Docker 数据管理</title>
    <link href="http://lujianan.com/2018/09/15/docker-data-management/"/>
    <id>http://lujianan.com/2018/09/15/docker-data-management/</id>
    <published>2018-09-15T07:13:53.000Z</published>
    <updated>2021-01-03T16:12:35.967Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 提供了3种方式将数据从Docker宿主机挂载到容器：</p><ul><li>Volumes</li><li>Bind mounts</li><li>tmpfs mounts</li></ul><p>一般来说，volumes总是最好的选择。</p><a id="more"></a><h2 id="容器写入层的缺点"><a href="#容器写入层的缺点" class="headerlink" title="容器写入层的缺点"></a>容器写入层的缺点</h2><p>我们可以将数据写到容器的可写入层，但是这种写入是有缺点的：</p><ul><li><p>当容器停止运行时，写入的数据会丢失。你也很难将这些数据从容器中取出来给另外的应用程序使用。</p></li><li><p>容器的可写入层与宿主机是紧密耦合的。这些写入的数据在可以轻易地被删掉。</p></li><li><p>写入容器的可写入层需要一个存储驱动（storage driver）来管理文件系统。这个存储驱动通过linux内核提供了一个union filesystem。相比于数据卷（data volume），这种额外的抽象会降低性能。</p></li></ul><h2 id="选择合适的挂载方式"><a href="#选择合适的挂载方式" class="headerlink" title="选择合适的挂载方式"></a>选择合适的挂载方式</h2><p>不管你选择哪种挂载方式，从容器中看都是一样的。数据在容器的文件系统中被展示为一个目录或者一个单独的文件。</p><p>一个简单区分 volumes，bind mounts 和 tmpfs mounts 不同点的方法是：思考数据在宿主机上是如何存在的。</p><p><img src="https://michaelyou.github.io/img/types-of-mounts.png" alt="image"></p><p>Volumes 由 Docker 管理，存储在宿主机的某个地方（在 linux 上是 <code>/var/lib/docker/volumes/</code>）。非 Docker 应用程序不能改动这一位置的数据。Volumes 是 Docker 最好的数据持久化方法。</p><ul><li><p>Volumes 由 Docker 创建和管理。你可以通过 <code>docker volume create</code> 命令显式地创建 volume，Docker 也可以在创建容器或服务是自己创建 volume。</p></li><li><p>当你创建了一个 volume，它会被存放在宿主机的一个目录下。当你将这个 volume 挂载到某个容器时，这个目录就是挂载到容器的东西。这一点和 bind mounts 类似，除了 volumes 是由 Docker 创建的，和宿主机的核心（core functionality）隔离。</p></li><li><p>一个 volume 可以同时被挂载到几个容器中。即使没有正在运行的容器使用这个 volume，volume 依然存在，不会被自动清除。可以通过 <code>docker volume prune</code> 清除不再使用的 volumes。</p></li><li><p>volumes 也支持 volume driver，可以将数据存放在另外的机器或者云上。</p></li></ul><p>Bind mounts 的数据可以存放在宿主机的任何地方。数据甚至可以是重要的系统文件或目录。非 Docker 应用程序可以改变这些数据。</p><ul><li><p>Docker 早期就支持这个特性。与 volumes 相比，Bind mounts 支持的功能有限。使用 bind mounts 时，宿主机上的一个文件或目录被挂载到容器上。</p></li><li><p>警告：使用 Bind mounts 的一个副作用是，容器中运行的程序可以修改宿主机的文件系统，包括创建，修改，删除重要的系统文件或目录。这个功能可能会有安全问题。</p></li></ul><p>tmpfs mounts 的数据只存储在宿主机的内存中，不会写入到宿主机的文件系统。</p><ul><li>tmpfs mounts 的数据不会落盘。在容器的生命周期内，它可以被用来存储一些不需要持久化的状态或敏感数据。例如，swarm 服务通过 tmpfs mounts 来将 secrets 挂载到一个服务的容器中去。</li></ul><h3 id="适合Volumes的场景"><a href="#适合Volumes的场景" class="headerlink" title="适合Volumes的场景"></a>适合Volumes的场景</h3><ul><li><p>在不同的容器中共享数据。</p></li><li><p>当 Docker 主机不能保证具有给定的目录或文件结构时，Volumes 可帮助你将 Docker 主机的配置与容器运行时分离。</p></li><li><p>当要将容器的数据存储在远程主机或云提供程序上的时候。</p></li><li><p>当你需要备份或迁移数据的时候。</p></li></ul><h3 id="适合bind-mounts的场景"><a href="#适合bind-mounts的场景" class="headerlink" title="适合bind mounts的场景"></a>适合bind mounts的场景</h3><ul><li><p>宿主机和容器共享配置文件。Docker 提供的 DNS 解决方案就是如此，将宿主机的 <code>/etc/resolv.conf</code> 挂载到每个容器中。</p></li><li><p>开发环境需要在宿主机和容器中共享代码。docker 的开发就是如此，毕竟容器中一般是没有编辑器的。</p></li><li><p>当 Docker 主机的文件或目录结构保证与容器所需的绑定装载一致时。</p></li></ul><h3 id="适合tmpfs-mounts的场景"><a href="#适合tmpfs-mounts的场景" class="headerlink" title="适合tmpfs mounts的场景"></a>适合tmpfs mounts的场景</h3><ul><li>tmpfs mounts 主要用在你既不想在容器内，又不想在宿主机文件系统保存数据的时候。这可能是出于安全原因，也可能是你的应用需要写非常多的非持久化数据，tmpfs mounts 这时候可以保证容器性能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 提供了3种方式将数据从Docker宿主机挂载到容器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Volumes&lt;/li&gt;
&lt;li&gt;Bind mounts&lt;/li&gt;
&lt;li&gt;tmpfs mounts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，volumes总是最好的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Docker" scheme="http://lujianan.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffer Encoding</title>
    <link href="http://lujianan.com/2018/06/03/protocol-buffer-encoding/"/>
    <id>http://lujianan.com/2018/06/03/protocol-buffer-encoding/</id>
    <published>2018-06-02T22:02:17.000Z</published>
    <updated>2021-01-03T16:12:35.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自： <a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/encoding</a></p></blockquote><p>本文档介绍了 protocol buffer message 的二进制格式。你不需要知道这个就可以在你的应用程序中使用 protocol buffer，但如果你想了解 protocol buffer 格式对编码后的 message 大小的影响，该文档非常有用。</p><a id="more"></a><h2 id="一个简单的-Message"><a href="#一个简单的-Message" class="headerlink" title="一个简单的 Message"></a>一个简单的 Message</h2><p>假设你有如下这个非常简单的 message 定义：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">message Test1 &#123;</span><br><span class="line">  optional int32 a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用程序中，你创建了一个 <code>Test1</code> message 并将 <code>a</code> 设置为 150，然后将 message 序列化为输出流。如果你能够检查编码后的 message，则会看到三个字节：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">08 96 01</span><br></pre></td></tr></table></figure><p>这些数字的含义是什么呢？我们将稍后展示。</p><h2 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h2><p>要理解 protocol buffer 的编码，首先需要了解 varints。varints 是一种将整数序列化成一个或多个字节的方法。数字越小使用的字节数也越小。</p><p>varint 中的每个字节（最后一个字节除外）都设置了最高有效位（most significant bit），简称 msb，表示还有后续字节，如果只有单个字节则不设置 msb。每个字节的低7位用于以7位一组的形式存储数字的二进制补码，<strong>最低有效组放在前面</strong>。</p><p>例如，数字1，它是一个单字节，所以 msb 没有被设置：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0000 0001</span><br></pre></td></tr></table></figure><p>如果是300，就有点复杂：</p><pre><code>1010 1100 0000 0010</code></pre><p>怎么知道这个是300的呢？首先从每个字节中删除 msb，因为 msb 只是告诉我们是否已达到数字的末尾。（如你所见，由于 varint 中有多个字节，所以 msb 被设置在第一个字节中）：</p><pre><code>1010 1100 0000 0010→ 010 1100  000 0010</code></pre><p>因为 varints 的最低有效组放在前面，所以需要反转两个7位组。最后进行拼接来获得实际的值：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">000 0010  010 1100</span><br><span class="line">→  000 0010 + 010 1100</span><br><span class="line">→  100101100</span><br><span class="line">→  256 + 32 + 8 + 4 = 300</span><br></pre></td></tr></table></figure><h2 id="Message-结构"><a href="#Message-结构" class="headerlink" title="Message 结构"></a>Message 结构</h2><p>protocol buffer 的 message 是一系列 key-value 对。message 的二进制形式只使用了字段的编号作为 key，每个字段的名称和声明类型则是在解码端通过引用 message 类型的定义（即 <code>.proto</code> 文件）来确定的。</p><p>在对一个 message 进行编码时，key 和 value 被连接成一个字节流。当 message 被解码时，解析器需要跳过它无法识别的字段。这样，在 message 中添加新字段后也不会影响到旧程序。为此，每个 key 实际上由两个值组成：</p><ol><li><code>.proto</code> 文件中的字段编号。</li><li>用来获取 value 长度信息的 wire 类型。</li></ol><p>可用的 wire 类型如下：</p><table><thead><tr><th>Type</th><th>Meaning</th><th>Used For</th></tr></thead><tbody><tr><td>0</td><td>Varint</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>64-bit</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>Length-delimited</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td>3</td><td>Start group</td><td>groups (deprecated)</td></tr><tr><td>4</td><td>End group</td><td>groups (deprecated)</td></tr><tr><td>5</td><td>32-bit</td><td>fixed32, sfixed32, float</td></tr></tbody></table><p>在流式 message 中的每个 key 都是一个值为 <code>(field_number &lt;&lt; 3) | wire_type</code> 的 varint。换句话说，数字的最后三位存储了 wire 类型。</p><p>现在让我们回过来看看之前那个简单的例子。你现在已经知道流中的第一个数字总是一个值为 varint 的 key，例子中 key 为 08（删除 msb）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">000 1000</span><br></pre></td></tr></table></figure><p>取最后三位得到 wire 类型（0），然后右移三位得到字段编号（1）。所以字段编号是1，值是一个 varint。结合前面讲到的 varint 解码知识，可以看到接下来的两个字节存储的值为150。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">96 01 = 1001 0110  0000 0001</span><br><span class="line">       → 000 0001 + 001 0110 (drop the msb and reverse the groups of 7 bits)</span><br><span class="line">       → 10010110</span><br><span class="line">       → 128 + 16 + 4 + 2 = 150</span><br></pre></td></tr></table></figure><h2 id="更多的-value-类型"><a href="#更多的-value-类型" class="headerlink" title="更多的 value 类型"></a>更多的 value 类型</h2><h4 id="有符号整型（Signed-Integers）"><a href="#有符号整型（Signed-Integers）" class="headerlink" title="有符号整型（Signed Integers）"></a>有符号整型（Signed Integers）</h4><p>正如你在前面的章节中看到的那样，与 wire 类型0相关的所有 protocol buffer 类型都被编码为 varints。但是，在编码负数时，有符号的 int 类型（<code>sint32</code> 和 <code>sint64</code>）与“标准” int 类型（<code>int32</code> 和 <code>int64</code>）之间存在很大差异。如果使用 <code>int32</code> 或 <code>int64</code> 作为负数的类型，则生成的 varint 长度总是为10个字节 - 实际上，它被视为非常大的无符号整数；如果使用 <code>sint32</code> 或 <code>sint64</code>，对应的 varint 则会使用 ZigZag 编码，所以效率更高。</p><p>ZigZag 编码将有符号整数映射为无符号整数，因此绝对值小的数字（例如-1）就会有一个小的 varint 编码值。ZigZag 以一种在正整数和负整数之间来回“zig-zags”的方式来实现，所以-1被编码为1，1被编码为2，-2被编码为3，依此类推，如下表所示：</p><table><thead><tr><th>Signed Original</th><th>Encoded As</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>-2</td><td>3</td></tr><tr><td>2147483647</td><td>4294967294</td></tr><tr><td>-2147483648</td><td>4294967295</td></tr></tbody></table><p>换句话说，每个 <code>sint32</code> 类型的值 n 被编码为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</span><br></pre></td></tr></table></figure><p>每个 <code>sint64</code> 类型的值 n 被编码为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</span><br></pre></td></tr></table></figure><p>注意第二个移位操作 <code>n &gt;&gt; 31</code> 是一个算术移位。所以，这个移位操作的值要么所有位都是0（如果 n 是正数），要么所有位都为1（如果 n 是负数）。</p><p>在解析 <code>sint32</code> 或 <code>sint64</code> 时，其值按上述过程的逆操作解码回原来的有符号数。</p><h4 id="非-varint-数字（Non-varint-Numbers）"><a href="#非-varint-数字（Non-varint-Numbers）" class="headerlink" title="非 varint 数字（Non-varint Numbers）"></a>非 varint 数字（Non-varint Numbers）</h4><p>非 varint 数字类型很简单，<code>double</code> 和 <code>fixed64</code> 的 wire 类型为1，它告诉解析器提取一块64位的数据；类似的， <code>float</code> 和 <code>fixed32</code> 的 wire 类型为5，它告诉解析器提取一块32位的数据。在这两种情况下，值都以小端字节顺序存储。</p><h4 id="字符串（Strings）"><a href="#字符串（Strings）" class="headerlink" title="字符串（Strings）"></a>字符串（Strings）</h4><p>wire 类型 2 （length-delimited）表示该值是 varint 编码的长度，后面跟着指定的数据字节数。</p><p>例如有下面这样的 message 类型：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">message Test2 &#123;</span><br><span class="line">  optional string b = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 b 的值设置为“testing”，会得到：</p><p>12 07 <span style="color:red">74 65 73 74 69 6e 67<span></span></span></p><p>红色的字节部分是 UTF8 编码的“testing”。这里的 key 是 0x12，可以得到字段编号为2，wire 类型为2。07 表示 value 的长度为7，随后的7个字节就是我们的字符串。</p><h4 id="嵌套的-Message（Embedded-Messages）"><a href="#嵌套的-Message（Embedded-Messages）" class="headerlink" title="嵌套的 Message（Embedded Messages）"></a>嵌套的 Message（Embedded Messages）</h4><p>下面是一个带有我们示例类型 Test1 的嵌入式 message 的定义：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">message Test3 &#123;</span><br><span class="line">  optional Test1 c = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是编码后的结果，Test1 的字段 <code>a</code> 设置为150：</p><p>1a 03 <span style="color:red">08 96 01<span></span></span></p><p>可以看到，最后三个字节与我们前面的第一个例子（<code>08 96 01</code>）完全相同，在它们前面是数字3。嵌入式 message 的处理方式与字符串完全相同（wire type = 2）。</p><h4 id="可选和重复的元素（Optional-And-Repeated-Elements）"><a href="#可选和重复的元素（Optional-And-Repeated-Elements）" class="headerlink" title="可选和重复的元素（Optional And Repeated Elements）"></a>可选和重复的元素（Optional And Repeated Elements）</h4><p>如果在 proto2 的 message 定义中有 <code>repeated</code> 的元素（没有<code>[packed = true]</code>选项），编码后的 message 会有零个或多个具有相同字段编号的 key-value 对。这些 repeated 的值不需要连续的出现，它们可能与其他的字段交错出现。解析时，这些元素相互之间的顺序会保存下来，但是相对于其他字段的顺序将会丢失。而 proto3 会利用打包编码（packed encoding）的方式对 repeated 字段进行编码，之后会介绍。</p><p>对于 proto3 中的任何非 <code>repeated</code> 字段或 proto2 中的 <code>optional</code> 字段，编码后的 message 可能有也可能没有该字段编号的 key-value 对。</p><p>通常，编码后的 message 永远不会有非 <code>repeated</code> 字段的多个实例。但是，解析器被设计为可以处理这种情况。对于数字类型和字符串，如果同一个字段出现多次，解析器将接受它看到的最后一个值。对于嵌套的 message 字段，解析器合并相同字段的多个实例，就像使用 <code>Message::MergeFrom</code> 方法一样 - 那就是，后面的实例的单个字段会替换掉前面出现的，单个嵌套 message 被合并，重复字段被连接起来。这些规则的效果是，解析串联出现的两个编码的 message 产生的结果和单独解析两个 message 然后合并它们的结果是相同的。示例如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MyMessage message;</span><br><span class="line">message.ParseFromString(str1 + str2);</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MyMessage message, message2;</span><br><span class="line">message.ParseFromString(str1);</span><br><span class="line">message2.ParseFromString(str2);</span><br><span class="line">message.MergeFrom(message2);</span><br></pre></td></tr></table></figure><p>这个特性有的时候挺有用的，我们可以在不知道两个 message 的具体类型的情况下合并它们。</p><h4 id="打包重复字段（Packed-Repeated-Fields）"><a href="#打包重复字段（Packed-Repeated-Fields）" class="headerlink" title="打包重复字段（Packed Repeated Fields）"></a>打包重复字段（Packed Repeated Fields）</h4><p>protocol buffer 在 2.1.0 版本引入了 packed repeated 字段，这个字段在 proto2 中的声明需要在 repeated 字段后面添加 <code>[packed=true]</code>。在 proto3 中，repeated 字段默认为 packed repeated 字段。这个字段和普通的 repeated 字段的区别在于编码方式不同。一个包含0个元素的 packed repeated 字段不会出现在编码后的 message 中。否则，该字段的所有元素都将打包到一个 wire 类型为2（length-delimited）的 key-value 对中。除了前面没有 key 以外，每个元素的编码方式与通常情况下相同。</p><p>假设你有如下的 message 类型：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">message Test4 &#123;</span><br><span class="line">  repeated int32 d = 4 [packed=<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在构造一个 <code>Test4</code>，repeated 字段 <code>d</code> 的值有3、270和86942。编码后的结果如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">22        // key (field number 4, wire <span class="built_in">type</span> 2)</span><br><span class="line">06        // payload size (6 bytes)</span><br><span class="line">03        // first element (varint 3)</span><br><span class="line">8E 02     // second element (varint 270)</span><br><span class="line">9E A7 05  // third element (varint 86942)</span><br></pre></td></tr></table></figure><p>只有原始数字类型（varint，32-bit 或 64-bit）的 repeated 字段才可以声明为“packed”。</p><p>请注意，虽然通常没有理由为 packed repeated 字段对多个 key-value 对进行编码，但编码器必须准备好接受多个 key-value 对。在这种情况下，payloads 应该被连接在一起。每一对都必须包含所有元素。</p><p>protocol buffer 解析器必须能够解析被编译为 packed 的 repeated 字段，就像它们未被打包一样，反之亦然。这就保证了 <code>[packed=true]</code> 选项的前后向兼容性。</p><h4 id="字段顺序（Field-Order）"><a href="#字段顺序（Field-Order）" class="headerlink" title="字段顺序（Field Order）"></a>字段顺序（Field Order）</h4><p>你可以在一个 .proto 文件中以任意顺序使用字段编号，当 message 被序列化时，已知的字段会按照字段编号顺序写入，可以参考提供的 C++，Java 和 Python 的序列化代码。这允许解析代码依赖于字段编号进行优化。但是，protocol buffer 解析器必须能够以任意顺序解析字段，因为并非所有 message 都是通过简单地序列化对象来创建的。例如，有时我们会通过一个简单的连接来合并两个 message。</p><p>如果 message 具有未知字段，则当前的 Java 和 C++ 实现在按顺序排序的已知字段之后以任意顺序写入它们，当前的 Python 实现则不会跟踪未知字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自： &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文档介绍了 protocol buffer message 的二进制格式。你不需要知道这个就可以在你的应用程序中使用 protocol buffer，但如果你想了解 protocol buffer 格式对编码后的 message 大小的影响，该文档非常有用。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Protocol Buffer" scheme="http://lujianan.com/tags/Protocol-Buffer/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffer 介绍</title>
    <link href="http://lujianan.com/2018/06/02/protocol-buffer-introduction/"/>
    <id>http://lujianan.com/2018/06/02/protocol-buffer-introduction/</id>
    <published>2018-06-01T18:39:05.000Z</published>
    <updated>2021-01-03T16:12:35.971Z</updated>
    
    <content type="html"><![CDATA[<p><code>protocol buffer</code> 是一种语言无关，平台无关，可扩展的序列化结构化数据的方式，用于通信协议，数据存储等。</p><a id="more"></a><p><code>protocol buffer</code> 目前支持Java，Python，Objective-C 和 C++ 中的生成代码。使用新的 <code>proto3</code> 语言版本，您还可以使用 Go，Ruby 和 C＃ 等更多语言。</p><h2 id="为什么选择-Protocol-Buffer-？"><a href="#为什么选择-Protocol-Buffer-？" class="headerlink" title="为什么选择 Protocol Buffer ？"></a>为什么选择 Protocol Buffer ？</h2><p>通常我们定义好的请求和响应在客户端和服务端都需要手动编码/解码，但是随着接口的版本变化，可能需要对版本号进行判断才能做相应的处理。这样使得新的协议变得复杂，因为开发者必须确保请求发起者与处理请求的实际服务器之间的所有服务器都能理解新协议，然后才能开始使用新协议。</p><p><code>protocol buffer</code> 旨在解决这些问题：</p><ul><li><p>可以很容易地引入新的字段，中间服务器可以简单地解析并传递数据，而无需了解所有字段。</p></li><li><p>协议格式的描述性更强，可以用各种语言来处理（C ++，Java等），并且速度更快，空间更小。</p></li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>开始使用 <code>protocol buffer</code> 的第一步，就是创建一个 <code>.proto</code> 文件来定义 <code>protocol buffer</code> 消息类型，指定你想要序列化的信息结构。</p><p>每个 <code>protocol buffer</code> 消息是一个小的逻辑信息记录，包含一系列 <code>name-value</code> 对。下面是 <code>.proto</code> 文件的一个例子，定义了一条包含人员信息的消息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">  required string name = 1;</span><br><span class="line">  required int32 id = 2;</span><br><span class="line">  optional string email = 3;</span><br><span class="line"></span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE = 0;</span><br><span class="line">    HOME = 1;</span><br><span class="line">    WORK = 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    required string number = 1;</span><br><span class="line">    optional PhoneType type = 2 [default = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phone = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，消息格式很简单。每种消息类型（如 <code>message Person</code>）都有一个或多个带有唯一编号的字段，每个字段都有一个名称和一个值类型。其中值类型可以是数字（整数或浮点数），布尔值，字符串，原始字节，甚至可以是其他 <code>protocol buffer</code> 的消息类型。在消息类型中，你可以指定可选字段，必填字段和重复字段。访问 <a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">Protocol Buffer Language Guide</a> 以获取更多有关 <code>.proto</code> 文件的信息。</p><p>当在 <code>.proto</code> 文件中定义完消息后，你需要运行 <code>protocol buffer</code> 编译器为你使用的编程语言生成数据访问类。这为每个字段提供了简单的访问器（如 <code>name()</code> 和 <code>set_name()</code>），以及对整个结构的进行序列化/解析的方法。例如，如果您选择的语言是 <code>C++</code>，那么在上面的示例中运行编译器将生成一个名为 <code>Person</code> 的类。然后，就可以在应用程序中使用此类来填充，序列化并检索 <code>Person</code> <code>protocol buffer</code> 消息。你可能会写下如下代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person person;</span><br><span class="line">person.set_name(<span class="string">"John Doe"</span>);</span><br><span class="line">person.set_id(<span class="number">1234</span>);</span><br><span class="line">person.set_email(<span class="string">"jdoe@example.com"</span>);</span><br><span class="line"><span class="function">fstream <span class="title">output</span><span class="params">(<span class="string">"myfile"</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">person.SerializeToOstream(&amp;output);</span><br></pre></td></tr></table></figure><p>然后，可以通过以下方式读取消息：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">input</span><span class="params">(<span class="string">"myfile"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">Person person;</span><br><span class="line">person.ParseFromIstream(&amp;input);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; person.name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"E-mail: "</span> &lt;&lt; person.email() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>你可以将新字段添加到消息格式中，而不会破坏向后兼容性; 解析时旧的二进制文件会简单地忽略新字段。所以如果你有一个使用 <code>protocol buffer</code> 作为数据格式的通信协议，你可以扩展你的协议，而不用担心破坏现有的代码。</p><p>详细的 <code>protocol buffer</code> 介绍以及使用请参考 <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;protocol buffer&lt;/code&gt; 是一种语言无关，平台无关，可扩展的序列化结构化数据的方式，用于通信协议，数据存储等。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Protocol Buffer" scheme="http://lujianan.com/tags/Protocol-Buffer/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 - 便利店在哪（已上线）</title>
    <link href="http://lujianan.com/2018/02/27/weapp-store/"/>
    <id>http://lujianan.com/2018/02/27/weapp-store/</id>
    <published>2018-02-27T11:46:22.000Z</published>
    <updated>2021-01-03T16:12:35.972Z</updated>
    
    <content type="html"><![CDATA[<p>业余时间做了一个小程序  “便利店在哪”，功能很简单，就是找出你附近的便利店。</p><a id="more"></a><p>灵感来源于经常找不到地方买烟。。。</p><p>代码已经开源在 Github 上了，地址：<a href="https://github.com/royeo/weapp-store" target="_blank" rel="noopener">royeo/weapp-store</a> ，欢迎 star。</p><p><img src="http://ovu6j7kst.bkt.clouddn.com/demo.png" style="margin-left: 0; border: 0"></p><p><img src="http://ovu6j7kst.bkt.clouddn.com/weapp.jpg" style="margin-left: 0; border: 0"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;业余时间做了一个小程序  “便利店在哪”，功能很简单，就是找出你附近的便利店。&lt;/p&gt;
    
    </summary>
    
      <category term="与日俱新" scheme="http://lujianan.com/categories/%E4%B8%8E%E6%97%A5%E4%BF%B1%E6%96%B0/"/>
    
    
      <category term="微信小程序" scheme="http://lujianan.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Node 循环依赖之源码解析</title>
    <link href="http://lujianan.com/2018/01/29/node-circular-dependency/"/>
    <id>http://lujianan.com/2018/01/29/node-circular-dependency/</id>
    <published>2018-01-29T13:59:08.000Z</published>
    <updated>2021-01-03T16:12:35.970Z</updated>
    
    <content type="html"><![CDATA[<p>今天来讲一讲 Node 循环依赖的问题，以官网上的例子结合 Node 源码来分析为什么循环依赖不会导致死循环，以及循环依赖可能造成的问题。</p><a id="more"></a><h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>循环依赖是两个或多个模块之间的关系，它们直接或间接地相互依赖以正常运行。</p><h2 id="循环依赖的案例"><a href="#循环依赖的案例" class="headerlink" title="循环依赖的案例"></a>循环依赖的案例</h2><p>官网上给出的例子是这样的：</p><p><code>a.js</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a starting'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in a, b.done = %j'</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a done'</span>);</span><br></pre></td></tr></table></figure><p><code>b.js</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'b starting'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in b, a.done = %j'</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b done'</span>);</span><br></pre></td></tr></table></figure><p><code>main.js</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'main starting'</span>);</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in main, a.done=%j, b.done=%j'</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>官网的解释是： <code>main.js</code> 先加载 <code>a.js</code>，然后 <code>a.js</code> 中会加载 <code>b.js</code>，但是在 <code>b.js</code> 中又加载了 <code>a.js</code>。这个时候为了防止无限循环，会将<code>a.js</code> 未完成的 <code>exports</code> 对象返回给 <code>b.js</code> 模块，接着 <code>b.js</code> 完成加载，并且它的 <code>exports</code> 对象被提供给 <code>a.js</code> 模块。</p><p>由此可以看出，之所以不会发生依赖的死循环，是因为模块能够导出未完成的 <code>exports</code> 对象。那么问题来了，为什么模块没有执行完，却能导出对象呢？</p><p>下面通过分析模块源码 <a href="https://github.com/nodejs/node/blob/master/lib/module.js" target="_blank" rel="noopener">lib/module.js</a> 来解答这个问题。要注意的是，核心模块和文件模块（用户编写的模块）的加载是不同的，本文只讨论文件模块的加载。为了便于理解，会对源码进行简化。</p><h2 id="Module-构造函数"><a href="#Module-构造函数" class="headerlink" title="Module 构造函数"></a>Module 构造函数</h2><p>在 Node 中，每个模块在被 <code>require</code> 导入的时候都会创建一个模块实例，即 <code>Module</code> 实例，并且 Node 会缓存每个模块的实例，以便在下次 <code>require</code> 该模块的时候可以直接从缓存中返回。</p><p>模块实例有一个 <code>exports</code> 属性，初始化为空对象。当我们在文件模块中通过 <code>module.exports</code> 或 <code>exports</code> 来导出的时候，其实就是在给模块实例的 <code>exports</code> 添加属性或者直接重写它。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Module 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  updateChildren(parent, <span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="require-方法"><a href="#require-方法" class="headerlink" title="require 方法"></a>require 方法</h2><p><code>require</code> 方法定义在 <code>Module</code> 的原型链上，被每个模块实例共享。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Module._load(id, <span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>require</code> 内部调用 <code>Module._load</code> 方法，下面是简化后的 <code>_load</code> 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取模块文件的绝对路径</span></span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有缓存，直接返回缓存中的模块实例的 exports 属性</span></span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是核心模块，使用 NativeModule.require 方法加载</span></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建模块实例，并存入缓存</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="built_in">module</span>.load(filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中，以模块的绝对路径作为模块id，优先从缓存中获取模块实例的 <code>exports</code> 属性。如果模块实例不在缓存中，则创建模块实例并存入缓存，最后根据模块id调用 <code>module.load</code> 加载该模块。</p><h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><p>模块的加载通过 <code>module.load</code> 方法完成，该方法根据模块的绝对路径确定文件扩展名，不同的文件扩展名采用不同的加载方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  <span class="keyword">this</span>.paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> extension = path.extname(filename) || <span class="string">'.js'</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">'.js'</span>;</span><br><span class="line">  Module._extensions[extension](<span class="keyword">this</span>, filename);</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以 <code>.js</code> 扩展名为例，处理方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions[<span class="string">'.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">module</span>._compile(internalModule.stripBOM(content), filename);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>module._compile</code> 方法对模块文件进行编译执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将模块代码包装在一个函数中</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在当前全局上下文中编译包装好的模块代码，并返回一个可执行的函数</span></span><br><span class="line">  <span class="keyword">var</span> compiledWrapper = vm.runInThisContext(wrapper, &#123; ... &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取模块目录的路径</span></span><br><span class="line">  <span class="keyword">var</span> dirname = path.dirname(filename);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩展 require 方法，如添加 require.resolve、require.cache 等属性</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">require</span> = internalModule.makeRequireFunction(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入模块实例的 exports 属性、require 方法、模块实例自身、完整文件路径</span></span><br><span class="line">  <span class="comment">// 和文件目录来执行该函数。</span></span><br><span class="line">  <span class="keyword">var</span> result = compiledWrapper.call(<span class="keyword">this</span>.exports, <span class="keyword">this</span>.exports, <span class="built_in">require</span>, <span class="keyword">this</span>,</span><br><span class="line">                                  filename, dirname);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Module.wrapper[<span class="number">0</span>] + script + Module.wrapper[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Module.wrapper = [</span><br><span class="line">  <span class="string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,</span><br><span class="line">  <span class="string">'\n&#125;);'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><code>vm.runInThisContext</code> 这个方法会在 V8 虚拟机环境中编译代码，并在当前全局的上下文中运行代码并返回结果。在全局上下文运行的好处是在模块中我们可以使用一些全局变量，如：<code>process</code>、<code>console</code> 等。具体参考：<a href="https://nodejs.org/dist/latest-v8.x/docs/api/vm.html" target="_blank" rel="noopener">vm 的官方文档</a>。</p><p>上面的代码使用 <code>Module.wrap</code> 将模块代码包装在函数中，这样就避免了作用域被污染，接着通过执行 <code>vm.runInThisContext</code> 返回一个可执行的函数，最后传入当前模块实例的 <code>exports</code> 属性、模块实例的 <code>this</code>，以及<code>require</code> 方法、完整文件路径和文件目录来执行该函数。</p><p>由此也可以看出，<code>module.exports</code> 和 <code>exports</code> 并不是全局的，而是在执行模块代码的包装函数时传入的参数（当前模块实例的 <code>exports</code>）。这也解释了为什么在文件模块中重写 <code>exports</code> 会无法导出，因为它只能改变函数形参的引用，而无法实际影响到当前模块实例的 <code>exports</code> 属性。</p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>在分析完模块的整个加载过程后，回到上面那个问题：为什么模块没有执行完，却能导出对象呢？关键就在于，在加载模块时，如果模块没有缓存，会先创建模块实例，然后存入缓存，再编译执行模块代码。</p><p>以官网的例子来说：</p><ol><li><p><code>a.js</code> 先加载，所以先缓存 <code>a.js</code> 的模块实例，然后编译执行 <code>a.js</code>。</p></li><li><p>在执行 <code>a.js</code> 的过程中，先导出 <code>exports.done = false</code>，此时 <code>a.js</code> 模块实例的 <code>exports</code> 属性值为 <code>{ done: false }</code>。接着加载 <code>b.js</code>。</p></li><li><p><code>b.js</code> 在执行过程中发现需要加载 <code>a.js</code>，此时由于 <code>a.js</code> 模块已经被缓存，所以直接获取到缓存中的 <code>a.js</code> 模块实例的 <code>exports</code> 属性，值为 <code>{ done: false }</code>，然后继续执行。</p></li><li><p><code>b.js</code> 执行完毕返回，<code>a.js</code> 继续执行。</p></li></ol><p>这种循环依赖导致的问题很明显：</p><ol><li><p><code>b.js</code> 在执行过程中获取到的 <code>a.js</code> 的导出可能是不完整的。</p></li><li><p>如果 <code>a.js</code> 在加载 <code>b.js</code> 后重写了 <code>module.exports</code>，<code>b.js</code> 中获取到的 <code>a.js</code> 的导出还是维持着旧的引用。</p></li></ol><p>具体的解决方案可以参考 Maples7 的博客：<a href="http://maples7.com/2016/08/17/cyclic-dependencies-in-node-and-its-solution/" target="_blank" rel="noopener">Node.js 中的模块循环依赖及其解决</a>。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://nodejs.org/docs/latest-v8.x/api/modules.html" target="_blank" rel="noopener">Modules | Node.js Documentation</a></li><li><a href="https://nodejs.org/docs/latest-v8.x/api/vm.html" target="_blank" rel="noopener">VM | Node.js Documentation</a></li><li><a href="https://github.com/nodejs/node/blob/master/lib/module.js" target="_blank" rel="noopener">node/lib/module.js - Github</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require() 源码解读 - 阮一峰</a></li><li><a href="https://segmentfault.com/a/1190000004151411" target="_blank" rel="noopener">Node.js 中的循环依赖 - SegmentFault</a></li><li><a href="http://maples7.com/2016/08/17/cyclic-dependencies-in-node-and-its-solution/" target="_blank" rel="noopener">Node.js 中的模块循环依赖及其解决 - Maples7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来讲一讲 Node 循环依赖的问题，以官网上的例子结合 Node 源码来分析为什么循环依赖不会导致死循环，以及循环依赖可能造成的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Node" scheme="http://lujianan.com/tags/Node/"/>
    
      <category term="模块" scheme="http://lujianan.com/tags/%E6%A8%A1%E5%9D%97/"/>
    
      <category term="源码" scheme="http://lujianan.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="循环依赖" scheme="http://lujianan.com/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs V8 的内存管理与垃圾回收机制</title>
    <link href="http://lujianan.com/2018/01/10/node-v8/"/>
    <id>http://lujianan.com/2018/01/10/node-v8/</id>
    <published>2018-01-10T13:34:39.000Z</published>
    <updated>2021-01-03T16:12:35.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="V8-的内存限制"><a href="#V8-的内存限制" class="headerlink" title="V8 的内存限制"></a>V8 的内存限制</h2><p>在 Node 中通过 javascirpt 只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB），这个限制会导致 Node 无法直接操作大内存对象，计算机的内存资源无法得到充足的使用。</p><a id="more"></a><p>造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 javascirpt 对象基本都是通过 V8 自己的方式进行分配和管理，V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，但在 Node 中却限制了开发者随心所欲使用大内存的想法。还有一个深层原因是 V8 的垃圾回收机制的限制。官方说法，以1.5GB的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JS线程暂停执行的时间，在这样时间花销下，应用的性能和响应能力都会直线下降。</p><p>在 V8 中，所有的 JS 对象都是通过堆来进行分配的。通过 <code>process.memoryUsage()</code> 命令可查看 V8 内存使用量：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  rss: 18702336,    </span><br><span class="line">  heapTotal: 10295296,  <span class="comment"># 已申请到的堆内存</span></span><br><span class="line">  heapUsed:5409936      <span class="comment"># 当前使用量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>V8 依然提供了选项让我们使用更多的内存，Node 在启动时可以传递 <code>--max-old-space-size</code> 或 <code>--max-new-space-size</code> 来调整内存限制的大小，启动之后就无法改变了。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --max-old-space-size=1700 app.js</span><br><span class="line">node --max-new-space-size=1024 app.js</span><br></pre></td></tr></table></figure><h2 id="V8-的垃圾回收机制"><a href="#V8-的垃圾回收机制" class="headerlink" title="V8 的垃圾回收机制"></a>V8 的垃圾回收机制</h2><p>在 V8 中，主要将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p><h3 id="新生代内存回收机制"><a href="#新生代内存回收机制" class="headerlink" title="新生代内存回收机制"></a>新生代内存回收机制</h3><p>新生代的对象通过 Scavenge 算法进行垃圾回收，她将新生代的堆内存空间一分为二，每个空间称为 semispace，其中一个处于使用中（ From 空间），另一个处于闲置状态（ To 空间）。当我们分配对象时，先是从 From 空间进行分配，当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象会被复制到 To 空间，而非存活对象占用的空间将会释放，也就是释放 From 空间。完成复制后，From 空间和 To 空间角色互换。简单来说，就是通过将存活对象在两个 semispace 空间之间进行复制。</p><p>在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件有两个，一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过限制。</p><ul><li><p>在对象从 From 空间复制到 To 空间时，会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收，如果已经经历过，会将该对象从 From 空间复制到老生代空间中，如果没有，则复制到 To 空间中。 </p></li><li><p>当从 From 空间复制一个对象到 To 空间时，如果 To 空间已经使用了超过25%，则这个对象直接晋升到老生代空间中。因为当这次 Scavenge 回收完成后，这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行，如果占比过高，会影响后续的内存分配。</p></li></ul><p>Scavenge 的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。由于 Scavenge 是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge 非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p><h3 id="老生代内存回收机制"><a href="#老生代内存回收机制" class="headerlink" title="老生代内存回收机制"></a>老生代内存回收机制</h3><p>对于老生代中的对象，由于存活对象占较大比重，再采用 Scavenge 的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8 在老生代中主要采用 Mark-Sweep 和 Mark-Compack 相结合的方式进行垃圾回收。</p><ul><li><p>Mark-Sweep</p><p>  Mark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。与 Scavenge 复制活着的对象不同，Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出 Scavenge 只复制活着的对象，Mark-Sweep 只清除死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因。</p></li><li><p>Mark-Compack</p><p>  Mark-Sweep 最大的问题是在进行一次标记清除后，内存空间会出现不连续的状态，这样内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><p>  为了解决 Mark-Sweep 的内存碎片问题，Mark-Compack 被提出来了。Mark-Compack 是标记整理的问题，是在 Mark-Sweep 的基础上演变而来的，它们的差别在于对象在标记为死亡后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p></li></ul><table><thead><tr><th>回收算法</th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Scavenge</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（有碎片）</td><td>少（无碎片）</td><td>双倍空间（无碎片）</td></tr><tr><td>是否移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>从表格上看，Mark-Sweep 和 Mark-Compact 之间，由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用 Mark-Compact。</p><h2 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h2><p>为了避免出现 js 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。在 V8 的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但 V8 的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。</p><p>为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让 js 应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。</p><p><img src="http://ovu6j7kst.bkt.clouddn.com/incremental_marking.png" alt="image"></p><p>V8 在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。V8 后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从 V8 的自动垃圾回收机制的设计角度可以看到，V8 对内存使用进行限制的缘由。新生代设计为一个较小的内存空间是合理的，而老生代空间过大对于垃圾回收并无特别意义。V8对内存限制的设置对于 Chrome 浏览器这种每个选项卡页面使用一个 V8 实例而言，内存的使用是绰绰有余，对于 Node 编写的服务器端来说，内存限制也并不影响正常场景下的使用。但是对于V8的垃圾回收特点和 js 在单线程上的执行情况，垃圾回收是影响性能的因素之一。想要高性能执行效率，需要注意让垃圾回收尽量少地进行，尤其是全堆垃圾回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;V8-的内存限制&quot;&gt;&lt;a href=&quot;#V8-的内存限制&quot; class=&quot;headerlink&quot; title=&quot;V8 的内存限制&quot;&gt;&lt;/a&gt;V8 的内存限制&lt;/h2&gt;&lt;p&gt;在 Node 中通过 javascirpt 只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB），这个限制会导致 Node 无法直接操作大内存对象，计算机的内存资源无法得到充足的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Node.js" scheme="http://lujianan.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>读后感：《 一只特立独行的猪 》 — 王小波</title>
    <link href="http://lujianan.com/2017/12/16/a-maverick-pig/"/>
    <id>http://lujianan.com/2017/12/16/a-maverick-pig/</id>
    <published>2017-12-16T14:15:46.000Z</published>
    <updated>2021-01-03T16:12:35.966Z</updated>
    
    <content type="html"><![CDATA[<p>第一次看到这个书名《一只特立独行的猪》，我觉得很有意思，一只猪如何做到特立独行？带着这个问题我读了王小波的这本杂文。</p><p>猪给我的印象就是被圈养在又脏又臭的狭小环境中（此处自动忽略网易的味央猪…），吃了睡，睡了吃，直到它成为餐桌上的食物，被广罗大众花式烹饪。但其实很多人不知道，猪其实是很聪明的生物，甚至比狗和黑猩猩都聪明，而且它们很爱干净。但因为长期活在人类的“统治”之下，猪接受了这样的设置，过着“井井有条”的生活。</p><a id="more"></a><p>书中的一篇杂文讲述了作者与这只特立独行的猪的经历，那是一个趣味十足又耐人寻味的故事。故事中猪是一只非常有灵性的猪，有山羊般的敏捷，也有猫一样的灵活，活的竟然有些潇洒。它没有配合宿命的安排，而是选择了抗争，即使是在面对惨烈的杀猪现场也能镇定自若，机智逃脱，重新主宰了自己的命运。这里特别想引用一下《乔布斯传》里提到的一句广告语：</p><blockquote><p>致疯狂的人。他们特立独行。他们桀骜不驯。他们惹是生非。他们格格不入。他们用与众不同的眼光看待事物。他们不喜欢墨守成规。他们也不愿安于现状。你可以认同他们，反对他们，颂扬或是诋毁他们。但唯独不能漠视他们。</p></blockquote><p>动物也好，人类也好，生存是亘古不变的话题，生存之下则有不同的活法。王小波写这只猪的故事仿佛也是在写他自己，他自己的特立独行，他的自由主义理念，与“猪兄”都不谋而合。恰逢那时候刚看完电影“猩球崛起”，感觉电影里的凯撒和这只猪有很多相似之处，它们都在打破常规，对设置好的生活勇敢的 say “no”，自己掌控着自己命运的方向盘，不怕风越大浪越高。反而是我们自己，可能还不如它们 。。。</p><blockquote><p>我已经四十岁了，除了这只猪，还没见过谁敢于如此无视对生活的设置。相反，我倒见过很多想要设置别人生活的人，还有对被设置的生活安之若素的人。因为这个缘故，我一直怀念这只特立独行的猪。</p><footer><strong>《 一只特立独行的猪 》</strong><cite>王小波</cite></footer></blockquote><p><br></p><p><img src="http://ovu6j7kst.bkt.clouddn.com/%E7%81%AB%E6%98%9F%E6%88%AA%E5%9B%BE_20171223_203016.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次看到这个书名《一只特立独行的猪》，我觉得很有意思，一只猪如何做到特立独行？带着这个问题我读了王小波的这本杂文。&lt;/p&gt;
&lt;p&gt;猪给我的印象就是被圈养在又脏又臭的狭小环境中（此处自动忽略网易的味央猪…），吃了睡，睡了吃，直到它成为餐桌上的食物，被广罗大众花式烹饪。但其实很多人不知道，猪其实是很聪明的生物，甚至比狗和黑猩猩都聪明，而且它们很爱干净。但因为长期活在人类的“统治”之下，猪接受了这样的设置，过着“井井有条”的生活。&lt;/p&gt;
    
    </summary>
    
      <category term="书海无涯" scheme="http://lujianan.com/categories/%E4%B9%A6%E6%B5%B7%E6%97%A0%E6%B6%AF/"/>
    
    
      <category term="王小波" scheme="http://lujianan.com/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
      <category term="一只特立独行的猪" scheme="http://lujianan.com/tags/%E4%B8%80%E5%8F%AA%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E7%8C%AA/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 相关技术书籍推荐</title>
    <link href="http://lujianan.com/2017/12/03/book-recommond/"/>
    <id>http://lujianan.com/2017/12/03/book-recommond/</id>
    <published>2017-12-03T12:54:24.000Z</published>
    <updated>2021-01-03T16:12:35.966Z</updated>
    
    <content type="html"><![CDATA[<p>接触 Node.js 也有段时间了，从一开始对 Node.js 一无所知，到现在能在项目中熟练使用，书籍、文档和实战缺一不可。在学习初期，书籍扮演着一个非常重要的角色，让我对 Node.js 有了一个系统的认识。从看《JavaScript高级程序设计》开始，陆陆续续看了不少 JavaScript、Node.js 以及后端技术的相关书籍。书看的越多，会越发觉得自己知识匮乏，然后就会去寻找更多的书来充实自己。下面就是我整理的 Node.js 后端开发相关的经典技术书籍，排名不分先后，括号内是豆瓣评分，仅作参考。部分书籍的 pdf 文件可以到我的 <a href="https://github.com/LemonSprite/free-programming-books.pdf" target="_blank" rel="noopener">Github</a> 上去下载。</p><a id="more"></a><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li>《JavaScript高级程序设计第三版》（9.3）</li><li>《你不知道的JavaScript》（9.4）</li><li>《JavaScript语言精粹》（9.1）</li><li>《JavaScript设计模式与开发实践》（9.2）</li><li>《JavaScript语言精髓与编程实践》（9.1）</li><li>《JavaScript面向对象精要》（9.0）</li><li>《JavaScript权威指南》（8.7）</li><li>《JavaScript函数式编程》（7.3）</li><li>《JavaScript设计模式》（8.4）</li><li>《JavaScript模式》（8.6）</li><li>《Effective JavaScript》（8.4）</li><li>《JavaScript忍者秘籍》（8.7）</li><li>《高性能JavaScript》（8.9）</li><li>《精通JavaScript》（8.6）  </li></ul><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ul><li>《Node.js实战》（8.4）</li><li>《深入浅出node.js》（8.7）</li><li>《The Node Beginner Book》（8.7）</li><li>《Node学习指南》（7.6）</li><li>《Node与Express开发》（7.5）</li><li>《Node.js开发指南》（7.5）</li><li>《Node.js权威指南》（7.3）</li><li>《Node即学即用》（7.3）</li></ul><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><ul><li>《高性能MySQL（第3版）》（9.3）</li><li>《MySQL技术内幕：InnoDB存储引擎（第2版）》（8.6）</li><li>《深入浅出MySQL 数据库开发 优化与管理维护 第2版》（8.3）</li><li>《高可用MySQL（第2版）》（8.0）</li><li>《SQL基础教程（第3版）》（8.8）</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li>《Redis实战》（8.3）</li><li>《Redis设计与实现》（8.5）</li></ul><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>《MongoDB权威指南 第2版》（8.1）</li><li>《MongoDB应用设计模式》（6.1）</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>《HTTP权威指南》（8.7）</li><li>《Web性能权威指南》（8.8）</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>《程序员修炼之道-从小工到大家》</li><li>《高效程序员的45个习惯 敏捷开发修炼之道》</li><li>《软件随想录》</li><li>《重构-改善既有代码的设计》</li><li>《代码简洁之道》</li><li>《高效团队开发的工具与方法》</li><li>《GitHub入门与实践》</li><li>《技术管理之巅》</li><li>《架构即未来》</li><li>《持续交付-发布可靠软件的系统方法》</li><li>《设计模式-可复用面向对象软件基础》</li><li>《设计模式之禅（第2版）》</li><li>《企业应用架构模式》</li><li>《领域驱动设计 软件核心复杂性应对之道》</li><li>《实现领域驱动设计》</li><li>《ZooKeeper：分布式过程协同技术详解》</li><li>《RabbitMQ实战：高效部署分布式消息队列》</li><li>《Redis设计与实现》</li><li>《实战Nginx：取代Apache的高性能Web服务器》</li><li>《大型网站技术架构 核心原理与案例分析》</li><li>《大型分布式网站架构设计与实践》</li><li>《微服务架构与实践》</li><li>《分布式服务框架原理与实践》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触 Node.js 也有段时间了，从一开始对 Node.js 一无所知，到现在能在项目中熟练使用，书籍、文档和实战缺一不可。在学习初期，书籍扮演着一个非常重要的角色，让我对 Node.js 有了一个系统的认识。从看《JavaScript高级程序设计》开始，陆陆续续看了不少 JavaScript、Node.js 以及后端技术的相关书籍。书看的越多，会越发觉得自己知识匮乏，然后就会去寻找更多的书来充实自己。下面就是我整理的 Node.js 后端开发相关的经典技术书籍，排名不分先后，括号内是豆瓣评分，仅作参考。部分书籍的 pdf 文件可以到我的 &lt;a href=&quot;https://github.com/LemonSprite/free-programming-books.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt; 上去下载。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Node.js" scheme="http://lujianan.com/tags/Node-js/"/>
    
      <category term="技术书籍" scheme="http://lujianan.com/tags/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>读后感：《 沉默的大多数 》 — 王小波</title>
    <link href="http://lujianan.com/2017/05/05/most-of-silence/"/>
    <id>http://lujianan.com/2017/05/05/most-of-silence/</id>
    <published>2017-05-05T14:41:43.000Z</published>
    <updated>2021-01-03T16:12:35.969Z</updated>
    
    <content type="html"><![CDATA[<p>初读王小波的书，觉得书中的故事大抵离当代社会有点距离。细细品来，方知个中思想在那个年代实属超前，妙言要道。书中很多文章读一遍，尚不能完全领会作者之深意，多次回顾与思辨，才感悟到其中的真知灼见，大有裨益，对于王小波的幽默与锐气也产生了由衷的赞赏。</p><a id="more"></a><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><p>话语教会我们很多，但善恶还是可以自明。话语想要教会我们，人与人生来就不平等。在人间，尊卑有序是永恒的真理，但你也可以不听。</p><p>一个人倘若需要从思想中得到快乐，那么他的第一个欲望就是学习。</p><p>知识虽然可以带来幸福，但假如把它压缩成药丸子灌下去，就丧失了乐趣。</p><p>正如上坡和下坡是一条路。</p><p>在科学上，有错误的学说，没有卑鄙的学说。</p><p>有些人受穷，是因为他不想富裕。</p><p>贫困是一种生活方式，富裕是另一种生活方式；追求聪明是一种人生的态度，追求愚蠢则是另一种生活态度。</p><p>吃苦必须有收益，牺牲必须有代价。</p><p>痛苦是艺术的源泉。</p><p>对残疾人的最大尊重，就是不把他当残疾人。</p><p>人生唯一的不幸就是自己的无能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初读王小波的书，觉得书中的故事大抵离当代社会有点距离。细细品来，方知个中思想在那个年代实属超前，妙言要道。书中很多文章读一遍，尚不能完全领会作者之深意，多次回顾与思辨，才感悟到其中的真知灼见，大有裨益，对于王小波的幽默与锐气也产生了由衷的赞赏。&lt;/p&gt;
    
    </summary>
    
      <category term="书海无涯" scheme="http://lujianan.com/categories/%E4%B9%A6%E6%B5%B7%E6%97%A0%E6%B6%AF/"/>
    
    
      <category term="王小波" scheme="http://lujianan.com/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 中文技术文档的写作规范</title>
    <link href="http://lujianan.com/2017/01/20/markdown-standard/"/>
    <id>http://lujianan.com/2017/01/20/markdown-standard/</id>
    <published>2017-01-20T11:33:25.000Z</published>
    <updated>2021-01-03T16:12:35.968Z</updated>
    
    <content type="html"><![CDATA[<div class="note class_name">            <p>本文转载自: <a href="https://github.com/ruanyf/document-style-guide" target="_blank" rel="noopener">https://github.com/ruanyf/document-style-guide</a> </p>          </div><p>中文技术文档的写作规范。</p><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>一级标题下，不能直接出现三级标题。</li><li>标题要避免孤立编号（即同级标题只有一个）。</li><li>下级标题不重复上一级标题的内容。</li><li>谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</li></ul><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><h3 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h3><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正确：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></table></figure><p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</span><br><span class="line"></span><br><span class="line">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。</span><br></pre></td></tr></table></figure><p>半角的百分号，视同阿拉伯数字。</p><p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：一部容量为 16 GB 的智能手机</span><br><span class="line"></span><br><span class="line">正确：一部容量为 16GB 的智能手机</span><br></pre></td></tr></table></figure><p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正确：他的电脑是 MacBook Air。</span><br></pre></td></tr></table></figure><h3 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h3><ul><li>避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。</li><li>尽量使用简单句和并列句，避免使用复合句。</li></ul><h3 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h3><p>尽量不使用被动语态，改为使用主动语态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正确：假如尚未安装这个软件，</span><br></pre></td></tr></table></figure><p>不使用非正式的语言风格。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正确：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></table></figure><p>用对“的”、“地”、“得”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></table></figure><p>使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></table></figure><p>名词前不要使用过多的形容词。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></table></figure><p>单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></table></figure><p>同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正确：请确认装置的电源已关闭。</span><br></pre></td></tr></table></figure><p>避免使用双重否定句。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正确：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></table></figure><h3 id="英文处理"><a href="#英文处理" class="headerlink" title="英文处理"></a>英文处理</h3><p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">英文：...information stored in random access memory (RAMs)...</span><br><span class="line"></span><br><span class="line">中文：……存储在随机存取存储器（RAM）里的信息……</span><br></pre></td></tr></table></figure><p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">U.S.A.</span><br><span class="line">Apple, Inc.</span><br></pre></td></tr></table></figure><p>表示中文时，英文省略号（<code>...</code>）应改为中文省略号（<code>……</code>）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">英文：5 minutes later...</span><br><span class="line"></span><br><span class="line">中文：5 分钟过去了……</span><br></pre></td></tr></table></figure><p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">英文：He published an article entitled &quot;The Future of the Aviation&quot;.</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></table></figure><p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</span><br></pre></td></tr></table></figure><p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></table></figure><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h3><ul><li>一个段落只能有一个主题，或一个中心句子。</li><li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li><li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li><li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li><li>段落之间使用一个空行隔开。</li><li>段落开头不要留出空白字符。</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用第三方内容时，应注明出处。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One man’s constant is another man’s variable. — Alan Perlis</span><br></pre></td></tr></table></figure><p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></table></figure><p>使用外部图片时，必须在图片下方或文末标明来源。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></table></figure><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="半角数字"><a href="#半角数字" class="headerlink" title="半角数字"></a>半角数字</h3><p>数字一律使用半角形式，不得使用全角形式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误： 这件商品的价格是１０００元。</span><br><span class="line"></span><br><span class="line">正确： 这件商品的价格是 1000 元。</span><br></pre></td></tr></table></figure><h3 id="千分号"><a href="#千分号" class="headerlink" title="千分号"></a>千分号</h3><p>数值为千位以上，应添加千分号（半角逗号）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XXX 公司的实收资本为 RMB1,258,000。</span><br></pre></td></tr></table></figure><p>对于 4 ～ 6 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于7位及以上的数值，千分号是必须的。</p><p>多位小数要从小数点后从左向右添加千分号，比如4.234,345。</p><h3 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h3><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$1,000</span><br><span class="line">1,000 美元</span><br></pre></td></tr></table></figure><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p><p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：132～234kg</span><br><span class="line">正确：132kg～234kg</span><br><span class="line"></span><br><span class="line">错误：67～89%</span><br><span class="line">正确：67%～89%</span><br></pre></td></tr></table></figure><h3 id="变化程度的表示法"><a href="#变化程度的表示法" class="headerlink" title="变化程度的表示法"></a>变化程度的表示法</h3><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></table></figure><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></table></figure><p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h3 id="原则-2"><a href="#原则-2" class="headerlink" title="原则"></a>原则</h3><ul><li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li><li>如果整句为英文，则该句使用英文/半角标点。</li><li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li></ul><h3 id="句号"><a href="#句号" class="headerlink" title="句号"></a>句号</h3><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p><p>句子末尾用括号加注时，句号应在括号之外。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</span><br><span class="line"></span><br><span class="line">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</span><br></pre></td></tr></table></figure><h3 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h3><p>逗号<code>，</code>表示句子内部的一般性停顿。</p><p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p><h3 id="顿号"><a href="#顿号" class="headerlink" title="顿号"></a>顿号</h3><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></table></figure><p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</span><br></pre></td></tr></table></figure><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</span><br></pre></td></tr></table></figure><p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></table></figure><h3 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h3><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br></pre></td></tr></table></figure><h3 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h3><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</span><br></pre></td></tr></table></figure><p>表示时间时，应使用半角冒号（<code>:</code>）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：早上 8:00</span><br></pre></td></tr></table></figure><h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p><p>省略号不应与“等”这个词一起使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></table></figure><h3 id="感叹号"><a href="#感叹号" class="headerlink" title="感叹号"></a>感叹号</h3><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p><p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p><h3 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h3><p>破折号<code>————</code>一般用于做进一步解释。破折号应占两个汉字的位置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br></pre></td></tr></table></figure><h3 id="连接号"><a href="#连接号" class="headerlink" title="连接号"></a>连接号</h3><p>连接号用于连接两个类似的词。</p><p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p><ul><li>两个名词的复合</li><li><p>图表编号</p><p>  例句：氧化-还原反应</p><p>  例句：图 1-1</p></li></ul><p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p><ul><li><p>数值范围（例如日期、时间或数字）</p><p>  例句：2009 年～2011 年</p></li></ul><p>注意，波浪连接号前后两个值都应该加上单位。</p><p>波浪连接号也可以用汉字“至”代替。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：周围温度：-20°C 至 -10°C</span><br></pre></td></tr></table></figure><h2 id="文档体系"><a href="#文档体系" class="headerlink" title="文档体系"></a>文档体系</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li>简介（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li><li>快速上手（Getting Started）：[可选] [文件] 如何最快速地使用产品</li><li>入门篇（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul><li>环境准备（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li>安装（Installation）：[可选] [文件] 软件的安装方法</li><li>设置（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li>进阶篇（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li><li>API（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</li><li>FAQ：[可选] [文件] 常见问题解答</li><li>附录（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul><li>Glossary：[可选] [文件] 名词解释</li><li>Recipes：[可选] [文件] 最佳实践</li><li>Troubleshooting：[可选] [文件] 故障处理</li><li>ChangeLog：[可选] [文件] 版本说明</li><li>Feedback：[可选] [文件] 反馈方式</li></ul></li></ul><p>下面是两个真实范例，可参考。</p><ul><li><a href="http://redux.js.org/index.html" target="_blank" rel="noopener">Redux 手册</a></li><li><a href="http://flight-manual.atom.io/" target="_blank" rel="noopener">Atom 手册</a></li></ul><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误： 名词解释.md</span><br><span class="line"></span><br><span class="line">正确： glossary.md</span><br></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：TroubleShooting.md</span><br><span class="line"></span><br><span class="line">正确：troubleshooting.md</span><br></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不佳：advanced_usage.md</span><br><span class="line"></span><br><span class="line">正确：advanced-usage.md</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html" target="_blank" rel="noopener">产品手册中文写作规范</a>, by 华为</li><li><a href="http://docs.daocloud.io/write-docs/format" target="_blank" rel="noopener">写作规范和格式规范</a>, by DaoCloud</li><li><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf" target="_blank" rel="noopener">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li><li><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf" target="_blank" rel="noopener">简体中文规范指南</a>, by lengoo</li><li><a href="https://open.leancloud.cn/copywriting-style-guide.html" target="_blank" rel="noopener">文档风格指南</a>, by LeanCloud</li><li><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit" target="_blank" rel="noopener">豌豆荚文案风格指南</a>, by 豌豆荚</li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a>, by sparanoid</li><li><a href="http://w3c.github.io/clreq/" target="_blank" rel="noopener">中文排版需求</a>, by W3C</li><li><a href="http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html" target="_blank" rel="noopener">为什么文件名要小写？</a>, by 阮一峰</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note class_name&quot;&gt;
            &lt;p&gt;本文转载自: &lt;a href=&quot;https://github.com/ruanyf/document-style-guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ruanyf/document-style-guide&lt;/a&gt; &lt;/p&gt;
          &lt;/div&gt;
&lt;p&gt;中文技术文档的写作规范。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="Markdown" scheme="http://lujianan.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引的创建、删除和查看</title>
    <link href="http://lujianan.com/2016/11/15/mysql-index/"/>
    <id>http://lujianan.com/2016/11/15/mysql-index/</id>
    <published>2016-11-15T14:04:35.000Z</published>
    <updated>2021-01-03T16:12:35.970Z</updated>
    
    <content type="html"><![CDATA[<p>在索引列上，除了有序查找之外，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。</p><a id="more"></a><p> 例如，有 3 个未索引的表 t1、t2、t3，分别只包含列 c1、c2、c3，每个表分别含有 1000 行数据组成，指为 1～1000 的数值，查找对应值相等行的查询如下所示。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1, t2, t3 <span class="keyword">WHERE</span> c1 = c2 <span class="keyword">AND</span> c1 = c3</span><br></pre></td></tr></table></figure><p>此查询结果应该为 1000 行，每行包含 3 个相等的值。在无索引的情况下处理此查询，必须寻找 3 个表所有的组合，以便得出与 WHERE 子句相配的那些行。而可能的组合数目为 1000 × 1000 × 1000（十亿），显然查询将会非常慢。</p><p>   如果对每个表进行索引，就能极大地加速查询进程。利用索引的查询处理如下。</p><p>（1）从表 t1 中选择第一行，查看此行所包含的数据。</p><p>（2）使用表 t2 上的索引，直接定位 t2 中与 t1 的值匹配的行。类似，利用表 t3 上的索引，直接定位 t3 中与来自 t1 的值匹配的行。</p><p>（3）扫描表 t1 的下一行并重复前面的过程，直到遍历 t1 中所有的行。</p><p>   在此情形下，仍然对表 t1 执行了一个完全扫描，但能够在表 t2 和 t3 上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。</p><p>   利用索引，MySQL 加速了 WHERE 子句满足条件行的搜索，而在多表连接查询时，在执行连接时加快了与其他表中的行匹配的速度。</p><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>在执行 CREATE TABLE 语句时可以创建索引，也可以单独用 CREATE INDEX 或 ALTER TABLE 来为表增加索引。</p><h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (column_list)</span><br></pre></td></tr></table></figure><p>其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名 index_name 可选，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER TABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><h3 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h3><p>CREATE INDEX 可对表增加普通索引或 UNIQUE 索引。</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list)</span><br></pre></td></tr></table></figure><p>table_name、index_name 和 column_list 具有与 ALTER TABLE 语句中相同的含义，索引名不可选。另外，不能用 CREATE INDEX 语句创建 PRIMARY KEY 索引。</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为 PRIMARY KEY 或 UNIQUE 索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。</p><p>PRIMARY KEY 索引和 UNIQUE 索引非常类似。事实上，PRIMARY KEY 索引仅是一个具有名称 PRIMARY 的 UNIQUE 索引。这表示一个表只能包含一个 PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p><p>下面的SQL语句对 students 表在 sid 上添加 PRIMARY KEY 索引。</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">sid</span>)</span><br></pre></td></tr></table></figure><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>可利用 ALTER TABLE 或 DROP INDEX 语句来删除索引。类似于 CREATE INDEX 语句，DROP INDEX 可以在 ALTER TABLE 内部作为一条语句处理，语法如下。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> talbe_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure><p>其中，前两条语句是等价的，删除掉 table_name 中的索引 index_name 。</p><p>第 3 条语句只在删除 PRIMARY KEY 索引时使用，因为一个表只可能有一个 PRIMARY KEY 索引，因此不需要指定索引名。如果没有创建 PRIMARY KEY 索引，但表具有一个或多个 UNIQUE 索引，则 MySQL 将删除第一个 UNIQUE 索引。</p><p>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from table_name;</span><br><span class="line"></span><br><span class="line">mysql&gt; show keys from table_name;</span><br></pre></td></tr></table></figure><ul><li><p>Table</p><p>  表的名称。</p></li><li><p>Non_unique</p><p>如果索引不能包括重复词，则为 0 。如果可以，则为 1 。</p></li><li><p>Key_name</p><p>索引的名称。</p></li><li><p>Seq_in_index</p><p>索引中的列序列号，从 1 开始。</p></li><li><p>Column_name</p><p>列名称。</p></li><li><p>Collation</p><p>列以什么方式存储在索引中。在 MySQL 中，有值 A（升序）或 NULL（无分类）。</p></li><li><p>Cardinality</p><p>索引中唯一值的数目的估计值。通过运行 ANALYZE TABLE 或 myisamchk -a 可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</p></li><li><p>Sub_part</p><p>如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为 NULL 。</p></li><li><p>Packed</p><p>指示关键字如何被压缩。如果没有被压缩，则为 NULL 。</p></li><li><p>Null</p><p>如果列含有 NULL，则含有 YES 。如果没有，则该列含有 NO 。</p></li><li><p>Index_type</p><p>用过的索引方法（BTREE，FULLTEXT，HASH，RTREE）。</p></li></ul><div class="note class_name">            <p>本文转载自：<a href="http://www.cnblogs.com/tianhuilove/archive/2011/09/05/2167795.html" target="_blank" rel="noopener">MySQL索引的创建、删除和查看</a> </p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在索引列上，除了有序查找之外，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="MySQL" scheme="http://lujianan.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 性能优化</title>
    <link href="http://lujianan.com/2016/09/02/mysql-optimization/"/>
    <id>http://lujianan.com/2016/09/02/mysql-optimization/</id>
    <published>2016-09-02T12:00:14.000Z</published>
    <updated>2021-01-03T16:12:35.970Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL性能优化的一些建议。</p><a id="more"></a><h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>比如有一条语句是这样的：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> area = <span class="string">'beijing'</span> <span class="keyword">and</span> age = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>如果我们是在 area 和 age 上分别创建单个索引的话，由于<strong>MySQL查询每次只能使用一个索引</strong>，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在 area、age 两列上创建复合索引的话将带来更高的效率。如果我们创建了 (area, age, salary) 的复合索引，那么其实相当于创建了 (area,age,salary)、(area,age)、(area) 三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</p><!--more--><h2 id="索引不会包含有NULL值的列"><a href="#索引不会包含有NULL值的列" class="headerlink" title="索引不会包含有NULL值的列"></a>索引不会包含有NULL值的列</h2><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为 NULL 。</p><h2 id="like语句操作"><a href="#like语句操作" class="headerlink" title="like语句操作"></a>like语句操作</h2><p>一般情况下不鼓励使用 like 操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引，而 like “aaa%” 可以使用索引。</p><h2 id="不要在列上进行运算"><a href="#不要在列上进行运算" class="headerlink" title="不要在列上进行运算"></a>不要在列上进行运算</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">YEAR</span>(adddate) &lt; <span class="number">2007</span>;</span><br></pre></td></tr></table></figure><p>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> adddate &lt; ‘<span class="number">2007</span><span class="number">-01</span><span class="number">-01</span>’;</span><br></pre></td></tr></table></figure><h2 id="不使用NOT-IN和-lt-gt-操作"><a href="#不使用NOT-IN和-lt-gt-操作" class="headerlink" title="不使用NOT IN和&lt;&gt;操作"></a>不使用NOT IN和&lt;&gt;操作</h2><p>NOT IN 和 &lt;&gt; 操作都不会使用索引将进行全表扫描。NOT IN 可以 NOT EXISTS 代替，id &lt;&gt; 3 则可使用 id &gt; 3 or id &lt; 3 来代替。</p><h2 id="不建议使用float、double来存小数"><a href="#不建议使用float、double来存小数" class="headerlink" title="不建议使用float、double来存小数"></a>不建议使用float、double来存小数</h2><p>为了防止精度丢失，建议使用 decimal 。</p><h2 id="高效分页"><a href="#高效分页" class="headerlink" title="高效分页"></a>高效分页</h2><p>limit m,n 其实是先执行 limit m + n，然后从第 m 行取 n 行，这样当 limit 翻页越往后越大，性能越低，如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">100000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>建议改成：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt;= (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">100000</span>, <span class="number">1</span>) <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h2><p>范围查找包括 between、大于、小于以及 in 。mysql 中的 in 查询的条件有数量的限制，数量较小可以走索引，数量较大，就成了全表扫描了。而 between、大于、小于等，这些查询不会走索引，所以尽量放在走索引的查询条件后面。</p><h2 id="多表链接"><a href="#多表链接" class="headerlink" title="多表链接"></a>多表链接</h2><p>子查询和 join 都可以实现多张表之间取数据，但是子查询的性能较差，建议使用 join 。对于mysql的 join ，它用的是 Nested Loop Join 算法，也就是通过前一个表查询的结果集去后一个表中查询，比如前一个表的结果集是 100 条数据，后一个表有 10W 数据，就需要在 100 × 10W 的数据集合中取过滤的到最终的结果集，因此，尽量用小结果集的表去和大表做 join ，同时在 join 的字段上建立索引。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL性能优化的一些建议。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="MySQL" scheme="http://lujianan.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何修复 503 Service Unavailable 错误</title>
    <link href="http://lujianan.com/2016/08/24/503-service-unavailable/"/>
    <id>http://lujianan.com/2016/08/24/503-service-unavailable/</id>
    <published>2016-08-24T03:52:37.000Z</published>
    <updated>2021-01-03T16:12:35.966Z</updated>
    
    <content type="html"><![CDATA[<div class="note class_name">            <p>本文翻译自: <a href="https://www.lifewire.com/503-service-unavailable-explained-2622940" target="_blank" rel="noopener">How to Fix a 503 Service Unavailable Error</a> </p>          </div><p>503 Service Unavailable 是一个 HTTP 状态码，表示 Web 服务器目前不可用。</p><a id="more"></a><h2 id="你可能看到的-503-错误信息"><a href="#你可能看到的-503-错误信息" class="headerlink" title="你可能看到的 503 错误信息"></a>你可能看到的 503 错误信息</h2><p>网站和服务器软件可以定制 503 错误信息，所以你可能看到不一样的错误信息。</p><p>以下是常见的 503 错误信息：</p><ul><li>503 Service Unavailable</li><li>503 Service Temporarily Unavailable</li><li>Http/1.1 Service Unavailable</li><li>HTTP Server Error 503</li><li>Service Unavailable - DNS Failure</li><li>503 Error</li><li>HTTP 503</li><li>HTTP Error 503</li><li>Error 503 Service Unavailable </li></ul><p>503 Service Unavailable 错误可能会出现在所有浏览器和所有操作系统上，包括 Window 10 / Window XP，MacOS，Linux等，甚至是你的手机和其他非主流操作系统。只要接入了互联网，那么你就有可能在某些情况下看到 503 错误。浏览器窗口会像显示网页一样显示 503 Service Unavailable 错误。</p><h2 id="503-Service-Unavailable-的错误原因"><a href="#503-Service-Unavailable-的错误原因" class="headerlink" title="503 Service Unavailable 的错误原因"></a>503 Service Unavailable 的错误原因</h2><p>大多数情况下，导致 503 错误的原因是服务器达到负载或正在进行维护。</p><p><strong>Note：</strong>使用 Microsoft IIS 的站点可以通过在 503 后面加一个后缀数字来提供有关 503 Service Unavailable 错误原因的更多具体信息，如 HTTP 错误 503.2 - 服务不可用，这意味着超出并发请求限制。</p><h2 id="如何修复-503-Service-Unavailable"><a href="#如何修复-503-Service-Unavailable" class="headerlink" title="如何修复 503 Service Unavailable"></a>如何修复 503 Service Unavailable</h2><p>503 Service Unavailable 是一个服务端的错误，意味着问题经常出在网站的服务器上，不太可能因为你的电脑的某种问题导致 503 错误。</p><p>无论如何，您可以尝试下面几件事情：</p><ol><li><p>通过点击重新加载/刷新按钮或按 F5 再次访问地址栏的 url。</p><p> 尽管 503 Service Unavailable 错误意味着服务器出现错误，但是这个问题可能只是暂时的，有时只要重新访问该页面就会起作用。</p><p> <strong>重要提示：</strong>如果在支付在线购买时出现 503 Service Unavailable 错误消息，请注意，多次尝试结帐可能会导致创建多个订单，并收取多笔费用！大多数支付系统和一些信用卡公司都有这种情况的保护措施，但仍然需要注意。</p></li><li><p>重启你的路由器和调制解调器，然后重启你的计算机或设备，尤其是当你看到 “Service Unavailable - DNS Failure” 的时候。</p><p> 虽然 503 错误最可能是你访问的网站导致的，但也有可能是你的路由器或计算机上的 DNS 服务器配置有问题，这两个简单的重启可能会修复这个问题。</p><p> <strong>提示：</strong>如果重启设备没有修复 503 DNS Failure 错误，那么可能是 DNS 服务器本身出现了临时问题。在这种情况下，从 <a href="https://www.lifewire.com/free-and-public-dns-servers-2626062" target="_blank" rel="noopener">免费和公共DNS服务器列表</a> 中选择新的 DNS 服务器，并在计算机或路由器上进行修改。如果需要帮助，请参阅 <a href="https://www.lifewire.com/how-to-change-dns-server-settings-2617979" target="_blank" rel="noopener">如何更改DNS服务器</a> 。</p></li><li><p>另一个选择是直接联系网站寻求帮助。网站的管理员很有可能已经知道 503 错误，但告知他们检查问题的状态，这不是一个坏主意。</p><p> 有关热门网站的联系信息，请参阅 <a href="https://www.lifewire.com/website-contact-information-2625174" target="_blank" rel="noopener">网站联系信息列表</a> 。大多数网站都有基于支持的社交网络帐户，有些甚至有电话号码和电子邮件地址。</p></li><li><p>稍后再访问。当访问者流量大幅增加导致服务器负载的时候，经常会出现 503 Service Unavailable 错误，这时候只需要等待一段时间再访问。随着越来越多的访问者离开网站，您的页面加载成功的可能性将会增加。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note class_name&quot;&gt;
            &lt;p&gt;本文翻译自: &lt;a href=&quot;https://www.lifewire.com/503-service-unavailable-explained-2622940&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to Fix a 503 Service Unavailable Error&lt;/a&gt; &lt;/p&gt;
          &lt;/div&gt;
&lt;p&gt;503 Service Unavailable 是一个 HTTP 状态码，表示 Web 服务器目前不可用。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="HTTP" scheme="http://lujianan.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>vscode 常用快捷键</title>
    <link href="http://lujianan.com/2016/07/21/vscode-hot-key/"/>
    <id>http://lujianan.com/2016/07/21/vscode-hot-key/</id>
    <published>2016-07-21T12:45:55.000Z</published>
    <updated>2021-01-03T16:12:35.971Z</updated>
    
    <content type="html"><![CDATA[<p>VSCode 的快捷键继承了一些 IDE 风格，有 VS 的身影，也有 Emacs 的身影。简言之，内置快捷键玩熟了，效率提高不是一点两点。</p><a id="more"></a><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>打开文件</td><td>Ctrl + O</td></tr><tr><td>打开文件夹</td><td>Ctrl + K + O</td></tr><tr><td>保存文件</td><td>Ctrl + S</td></tr><tr><td>另存为</td><td>Ctrl + Shift + S</td></tr><tr><td>新建文件</td><td>Ctrl + N</td></tr><tr><td>关闭当前文件</td><td>Ctrl + W 或 Ctrl + F4</td></tr><tr><td>关闭所有编辑窗口</td><td>Ctrl + K + W</td></tr><tr><td>打开新编辑器</td><td>Ctrl + Shift + N</td></tr><tr><td>关闭编辑器</td><td>Ctrl + Shift + W</td></tr><tr><td>撤销最近关闭的一个文件编辑窗口</td><td>Ctrl + Shift + T</td></tr><tr><td>切换打开的文件</td><td>Ctrl + Tab</td></tr><tr><td>快速切换文件，可搜索</td><td>Ctrl + E 或 Ctrl + P</td></tr><tr><td>切换标签页的位置</td><td>Ctrl + Shift + PgUp / PgDown</td></tr><tr><td>多个编辑窗口</td><td>Ctrl + 1 Ctrl + 2 Ctrl + 3 或 Ctrl + \ 或 Ctrl + Click file</td></tr></tbody></table><h2 id="代码编辑"><a href="#代码编辑" class="headerlink" title="代码编辑"></a>代码编辑</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>代码行缩进</td><td>Ctrl + [、Ctrl + ]</td></tr><tr><td>折叠/展开区域代码</td><td>Ctrl + Shift + [、Ctrl + Shift + ]</td></tr><tr><td>折叠/展开所有子区域代码</td><td>Ctrl + K + [、Ctrl + K + ]</td></tr><tr><td>折叠/展开所有区域代码</td><td>Ctrl + K + 0、Ctrl + K + J</td></tr><tr><td>注释/取消注释</td><td>Ctrl + /</td></tr><tr><td>块区域注释</td><td>Shift + Alt + A</td></tr><tr><td>添加函数注释</td><td>Ctrl + Alt + D + D</td></tr><tr><td>选中当前行</td><td>Ctrl + i</td></tr><tr><td>删除当前行</td><td>Ctrl + Shift + K 或 Shift + Delete</td></tr><tr><td>删除光标右侧的单词</td><td>Ctrl + Delete</td></tr><tr><td>在当前行下边插入一行</td><td>Ctrl + Enter</td></tr><tr><td>在当前行上方插入一行</td><td>Ctrl + Shift + Enter</td></tr><tr><td>历史文件切换</td><td>Alt + Left / Right</td></tr><tr><td>当前代码行上下移动</td><td>Alt + Up / Down</td></tr><tr><td>向上向下复制一行</td><td>Shift + Alt + Up / Down</td></tr><tr><td>视图上下偏移</td><td>Ctrl + Up / Down</td></tr><tr><td>跳转到上一个 / 下一个错误或者警告</td><td>F8 / Shift + F8</td></tr></tbody></table><h2 id="光标相关"><a href="#光标相关" class="headerlink" title="光标相关"></a>光标相关</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>移动到行首</td><td>Home</td></tr><tr><td>移动到行尾</td><td>End</td></tr><tr><td>选择从光标到行首</td><td>Shift + Home</td></tr><tr><td>选择从光标到行尾</td><td>Shift + End</td></tr><tr><td>移动到文件开头</td><td>Ctrl + Home</td></tr><tr><td>移动到文件结尾</td><td>Ctrl + End</td></tr><tr><td>跳转到指定行</td><td>Ctrl + G</td></tr><tr><td>扩展选取范围</td><td>Shift + Alt + Right</td></tr><tr><td>缩小选取范围</td><td>Shift + Alt + Left</td></tr><tr><td>匹配并跳转到花括号的闭合处</td><td>Ctrl + Shift + \</td></tr><tr><td>插入光标-支持多个</td><td>Alt + Click</td></tr><tr><td>上下插入光标-支持多个</td><td>Shift + Alt + Click 或 Ctrl + Alt + Up / Down</td></tr><tr><td>撤销最后一次光标操作</td><td>Ctrl + U</td></tr><tr><td>插入光标到选中范围内所有行结束符</td><td>Shift + Alt + i</td></tr><tr><td>插入光标到所有匹配到的末尾</td><td>Ctrl + Shift + L</td></tr></tbody></table><h2 id="查询与替换"><a href="#查询与替换" class="headerlink" title="查询与替换"></a>查询与替换</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>当前文件中查找</td><td>Ctrl + F</td></tr><tr><td>整个文件夹中查找</td><td>Ctrl + Shift + F</td></tr><tr><td>下一个 / 上一个查询结果</td><td>F3 / Shift + F3</td></tr><tr><td>选中所有出现在查询中的</td><td>Alt + Enter</td></tr><tr><td>当前文件中查找替换</td><td>Ctrl + H</td></tr><tr><td>整个文件夹中查找替换</td><td>Ctrl + Shift + H</td></tr></tbody></table><h2 id="语言操作"><a href="#语言操作" class="headerlink" title="语言操作"></a>语言操作</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>Emmet指令触发 / 缩进</td><td>Tab</td></tr><tr><td>格式化代码</td><td>Shift + Alt + F</td></tr><tr><td>格式化选中部分的代码</td><td>Ctrl + K + F</td></tr><tr><td>跳转到定义处</td><td>F12</td></tr><tr><td>查看定义处缩略图</td><td>Alt + F12</td></tr><tr><td>查看引用</td><td>Shift + F12</td></tr><tr><td>在其他窗口打开定义处</td><td>Ctrl + K + F12</td></tr><tr><td>快速修复部分可以修复的语法错误</td><td>Ctrl + .</td></tr><tr><td>重命名符号以及所有引用</td><td>F2</td></tr><tr><td>移除空白字符</td><td>Ctrl + K + X</td></tr></tbody></table><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>打开命令面板</td><td>F1 或 Ctrl + Shift + P</td></tr><tr><td>全屏</td><td>F11</td></tr><tr><td>放大 / 缩小字体</td><td>Ctrl + = / Ctrl + -</td></tr><tr><td>预览markdown</td><td>Ctrl + Shift + V</td></tr><tr><td>显示 / 隐藏侧边栏</td><td>Ctrl + B</td></tr><tr><td>打开资源视图</td><td>Ctrl + Shift + E</td></tr><tr><td>打开全局搜索</td><td>Ctrl + Shift + F</td></tr><tr><td>打开 Git 可视管理</td><td>Ctrl + Shift + G</td></tr><tr><td>打开 DeBug 面板</td><td>Ctrl + Shift + D</td></tr><tr><td>打开插件市场面板</td><td>Ctrl + Shift + X</td></tr><tr><td>打开问题面板</td><td>Ctrl + Shift + M</td></tr><tr><td>打开输出面板</td><td>Ctrl + Shift + U</td></tr><tr><td>打开调试控制台面板</td><td>Ctrl + Shift + Y</td></tr></tbody></table><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>启动调试、继续</td><td>F5</td></tr><tr><td>添加 / 删除断点</td><td>F9</td></tr><tr><td>单步跳过</td><td>F10</td></tr><tr><td>单步进入 / 单步跳出</td><td>F11 / Shift + F11</td></tr><tr><td>显示悬浮</td><td>Ctrl + k + i</td></tr></tbody></table><h2 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>打开集成终端</td><td>Ctrl + `</td></tr><tr><td>创建一个新的终端</td><td>Ctrl + Shift + `</td></tr><tr><td>页面上下翻屏</td><td>Shift + PgUp / PgDown</td></tr><tr><td>滚动到页面头部或尾部</td><td>Ctrl + Home / End</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>修改主题</td><td>F1 后输入 theme 回车，然后上下键即可预览</td></tr><tr><td>修改默认快捷键</td><td>File -&gt; Preferences -&gt; Keyboard Shortcuts</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VSCode 的快捷键继承了一些 IDE 风格，有 VS 的身影，也有 Emacs 的身影。简言之，内置快捷键玩熟了，效率提高不是一点两点。&lt;/p&gt;
    
    </summary>
    
      <category term="码梦为生" scheme="http://lujianan.com/categories/%E7%A0%81%E6%A2%A6%E4%B8%BA%E7%94%9F/"/>
    
    
      <category term="快捷键" scheme="http://lujianan.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
      <category term="VS Code" scheme="http://lujianan.com/tags/VS-Code/"/>
    
      <category term="editor" scheme="http://lujianan.com/tags/editor/"/>
    
  </entry>
  
</feed>
